<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机操作系统</title>
    <link href="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h1><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%A6%82%E8%BF%B0.md#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E6%A6%82%E8%BF%B0">资料来源</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>并发指在一段时间内能同时运行多个程序，并行指同一时刻能运行多个指令。</p><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p>共享指系统中的资源可以被多个并发进程共同使用，分为互斥共享、同时共享。</p><ul><li>互斥共享：其资源被称为临界资源，在同一时刻只允许一个进程访问，需要用同步机制来是想互斥访问。</li></ul><h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><p>将一个物理实体转换为多个逻辑实体</p><p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术</p><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>计算机多线程的异步处理：与同步处理相对，异步处理不用阻塞当前线程来等待处理完成，而是允许后续操作，直至其它线程将处理完成，并回调通知此线程。</p><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><ul><li>进程管理</li><li>内存管理</li><li>文件管理</li><li>设备管理</li></ul><h3 id="宏内核和微内核"><a href="#宏内核和微内核" class="headerlink" title="宏内核和微内核"></a>宏内核和微内核</h3><ul><li><strong>宏内核</strong>：宏内核是将操作系统功能作为一个紧密结合的整体放到内核。由于各模块共享信息，因此有<strong>很高的性能</strong>。</li><li><strong>微内核</strong>：由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而<strong>降低内核的复杂性</strong>。移出的部分根据分层的原则划分成若干服务，相互独立。因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的<strong>性能损失</strong>。</li></ul><h3 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h3><ul><li>外中断</li><li>异常</li><li>陷入</li></ul><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><ul><li><strong>进程</strong>：资源分配的基本单位。</li><li><strong>线程</strong>：线程是独立调度的基本单位。一个<strong>进程</strong>可以有多个<strong>线程</strong>，他们共享进程资源。</li><li><strong>区别</strong>：<ol><li>拥有资源：进程是资源分配的基本单位，但是<strong>线程不拥有资源</strong>，线程可以访问隶属进程的资源。</li><li>调度：线程是独立调度的基本单位，在同一进程中，<strong>线程的切换不会引起进程切换</strong>，从一个进程的线程切换到另一个进程的线程，<strong>会引起进程切换</strong>。</li><li>系统开销：创建或撤销<strong>进程</strong>时，系统都要为之分配或回收资源，所付出的开销远大于创建或撤销<strong>线程</strong>时的开销。</li><li>通信方面：<strong>线程</strong>间可以通过直接读写同一进程中的数据进行通信，但是<strong>进程</strong>通信需要借助IPC（进程间通信）。</li></ol></li></ul><h3 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h3><ul><li>就绪状态：等待被调度</li><li>运行状态</li><li>阻塞状态：等待资源</li></ul><p>注意以下内容</p><ul><li><strong>只有就绪态和运行态可以相互转换</strong>，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是<strong>缺少需要的资源</strong>从而由运行状态转换而来，但是该资源<strong>不包括 CPU 时间</strong>，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）</p><ul><li><strong>先来先服务 first-come first-serve (FCFS)<strong>：非抢占式的调度算法，按照</strong>请求的顺序</strong>进行调度。利于长作业不利于短作业（等待长作业执行完毕会导致作业等待时间过长）。</li><li><strong>短作业优先 shortest job first (SJF)<strong>：非抢占式的调度算法，按</strong>估计运行时间最短的顺序</strong>进行调度。（长作业一直处于等待短作业执行完毕的状态，因此如果等待期间一直有短作业到来，那么长作业将永远得不到调度）</li><li><strong>最短剩余时间优先 shortest remaining time next (SRTN)<strong>：最短作业优先的抢占式版本，按</strong>剩余运行时间的顺序</strong>进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</li></ul><h4 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h4><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><ul><li><p><strong>时间片轮转</strong>：将所有就绪进程按 <strong>FCFS</strong> 的原则排成一个队列，每次调度时，把 CPU 时间<strong>分配给队首进程</strong>，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它<strong>送往就绪队列的末尾</strong>，同时继续把 CPU 时间<strong>分配给队首的进程</strong>。</p><p>时间片轮转算法的效率和时间片的大小有很大关系：</p><ul><li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致<strong>进程切换得太频繁</strong>，在进程切换上就会花过多时间。</li><li>而如果时间片过长，那么<strong>实时性</strong>就不能得到保证。</li></ul></li><li><p><strong>优先级调度</strong>：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以<strong>随着时间的推移增加等待进程的优先级</strong>。</p></li><li><p><strong>多级反馈队列</strong>：一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了<strong>多个队列</strong>，每个队列<strong>时间片大小都不同</strong>，例如 1,2,4,8,..。进程在<strong>第一个队列</strong>没执行完，就会被移到<strong>下一个队列</strong>。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，<strong>最上面的优先权最高</strong>。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p></li></ul><h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><p>实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>对临界资源（一次仅允许一个进程使用的资源）进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><h4 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h4><ul><li><strong>同步</strong>：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li><strong>互斥</strong>：多个进程在同一时刻只有一个进程能够进入临界区。</li></ul><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量    *"></a>信号量    *</h4><p>是在<strong>多线程环境</strong>下使用的一种设施，是可以用来保证两个或多个关键代码段不被<strong>并发</strong>调用。</p><p>信号量是一个整型变量，可对其执行down和up操作，也就是常见的P和V操作。</p><ul><li>down：如果信号量大于0，执行-1操作；如果信号量等于0，进程睡眠，等待信号量大于0。</li><li>up：对信号量执行+1操作，唤醒睡眠的进程让其完成down操作。</li></ul><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁</p><h4 id="管程"><a href="#管程" class="headerlink" title="管程    *"></a>管程    *</h4><p>在功能上和信号量及PV操作类似，属于一种进程同步互斥工具，但具有与信号量及PV操作不同的属性。</p><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p><p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p><p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题    *"></a>哲学家进餐问题    *</h4><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><p>下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p><p>为了防止死锁的发生，可以设置两个条件：</p><ul><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ul><h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题    *"></a>读者-写者问题    *</h4><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程同步与进程通信很容易混淆，它们的区别在于：</p><ul><li><strong>进程同步</strong>：控制多个进程按一定顺序执行</li><li><strong>进程通信</strong>：进程间传输信息</li></ul><p>为了达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><h4 id="管道"><a href="#管道" class="headerlink" title="管道    *"></a>管道    *</h4><p>管道时通过调用pipe函数创建的，fd[0]用于读，fd[1]用于写。</p><p>它具有以下限制：</p><ul><li>只支持半双工通信（单项交替传输）</li><li>只能在父子进程或者兄弟进程中使用。</li></ul><h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO    *"></a>FIFO    *</h4><p>也成为<strong>命名管道</strong>，去除了管道只能在父子进程中使用的限制。</p><p>FIFO常用于客户-服务器应用程序中，FIFO用作汇聚点，在客户进程和服务器进程之间传递数据。</p><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列    *"></a>消息队列    *</h4><p>相比于FIFO，消息队列具有以下优点：</p><ul><li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li><li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li></ul><h4 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h4><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p><h4 id="共享储存"><a href="#共享储存" class="headerlink" title="共享储存    *"></a>共享储存    *</h4><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p><h4 id="套接字"><a href="#套接字" class="headerlink" title="套接字    *"></a>套接字    *</h4><p>与其他通信机制不同的是，它可用于不同机器间的进程通信。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ul><li><strong>互斥</strong>：每个资源要么已经分配给了一个进程，要么就是可用的。</li><li><strong>占有和等待</strong>：已经得到了某个资源的进程可以再请求新的资源。</li><li><strong>不可抢占</strong>：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li><li><strong>环路等待</strong>：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li></ul><h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><p>主要有以下四种方法：</p><ul><li>鸵鸟策略</li><li>死锁检测与死锁恢复</li><li>死锁预防</li><li>死锁避免</li></ul><h4 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h4><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为<strong>解决死锁问题的代价很高</strong>，因此鸵鸟策略这种不采取任务措施的方案会<strong>获得更高的性能</strong>。</p><p><strong>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</strong></p><p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是<strong>忽略</strong>它。</p><h4 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复    *"></a>死锁检测与死锁恢复    *</h4><p>不是图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><ol><li><p><strong>每种类型一个资源的死锁检测</strong></p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220620171309516-165586531113612.png" alt="image-20220620171309516" style="zoom:67%;"><p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p><p>图 a 可以抽取出环，如图 b，它<strong>满足了环路等待条件</strong>，因此会发生死锁。</p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p></li><li><p><strong>每种类型多个资源的死锁检测</strong></p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220621093312175-165586531113613.png" alt="image-20220621093312175" style="zoom:67%;"><p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p><ul><li>E 向量：资源总量</li><li>A 向量：资源剩余量</li><li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li><li>R 矩阵：每个进程请求的资源数量</li></ul><p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A &#x3D; (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A &#x3D; (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</p><p>算法总结如下：</p><p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p><ol><li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li><li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li><li>如果没有这样一个进程，算法终止。</li></ol></li><li><p><strong>死锁恢复</strong></p><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul></li></ol><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>在程序运行之前预防发生死锁</p><ol><li><p><strong>破坏互斥条件</strong></p><p>例如假脱机打印机技术运行若干个进程同时输出，唯一真正请求物理打印机的进程是打印机<strong>守护进程</strong>（一类在后台运行的特殊进程，用于执行特定的系统任务）。</p></li><li><p><strong>破坏占有和等待条件</strong></p><p>一种实现方式是规定所有进程给在开始执行前请求所需要的全部资源。</p></li><li><p><strong>破坏不可抢占条件</strong></p></li><li><p><strong>破坏坏路等待</strong></p><p>给资源同一编号，进程只能按编号顺序来请求资源。</p></li></ol><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免    *"></a>死锁避免    *</h3><p>在程序运行时避免发生死锁。</p><ol><li><p><strong>安全状态</strong></p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220621095511066-165586531113614.png" alt="image-20220621095511066" style="zoom:67%;"><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的<strong>最大</strong>需求，也仍然存在某种调度次序能够使得<strong>每一个进程</strong>运行完毕，则称该状态是安全的。</p><p>安全状态的检测与死锁的检测类似，因为安全状态<strong>必须</strong>要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p></li><li><p><strong>单个资源的银行家算法</strong></p><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220621095957138-165586531113615.png" alt="image-20220621095957138" style="zoom:67%;"><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p></li><li><p><strong>多个资源的银行家算法</strong></p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220621100310094-165586531113616.png" alt="image-20220621100310094" style="zoom:67%;"><p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A&#x3D;(1020)，表示 4 个资源分别还剩下 1&#x2F;0&#x2F;2&#x2F;0。</p><p>检查一个状态是否安全的算法如下：</p><ul><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ul><p>如果一个状态不是安全的，需要拒绝进入这个状态。</p></li></ol><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存    *"></a>虚拟内存    *</h3><p>虚拟内存的目的是为了让<strong>物理内存</strong>扩充成更大的<strong>逻辑内存</strong>，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p><h3 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射    *"></a>分页系统地址映射    *</h3><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p><p>一个虚拟地址分成两个部分，一部分存储<strong>页面号</strong>，一部分存储<strong>偏移量</strong>。</p><p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220621111131728-165586531113617.png" alt="image-20220621111131728" style="zoom:67%;"><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘兑换去中来腾出空间。</p><p>页面置换算法和缓存淘汰策略类似，可以将内存堪称磁盘的缓存，在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h4 id="最优替换算法（OPT）"><a href="#最优替换算法（OPT）" class="headerlink" title="最优替换算法（OPT）"></a>最优替换算法（OPT）</h4><p>所选择的被换出的页面僵尸最长时间内不再被访问，通常可以保证获得最低的却也略。</p><p>这是一种理论上的算法，因为无法知道一个页面多长时间不再访问。</p><p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">7</span>，<span class="hljs-number">0</span>，<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">0</span>，<span class="hljs-number">3</span>，<span class="hljs-number">0</span>，<span class="hljs-number">4</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">0</span>，<span class="hljs-number">3</span>，<span class="hljs-number">2</span>，<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">0</span>，<span class="hljs-number">1</span>，<span class="hljs-number">7</span>，<span class="hljs-number">0</span>，<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>开始运行时，先将7,0,1三个页面装入内存。当进程要访问页面2时，产生缺页中断，会将页面7换出，因为页面7再次被访问的时间最长。</p><h4 id="最近最久未使用（LRU）"><a href="#最近最久未使用（LRU）" class="headerlink" title="最近最久未使用（LRU）"></a>最近最久未使用（LRU）</h4><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU将最近最久未使用的页面换出。</p><p>为了实现LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这页面移到链表表头。这样就能保证链表表尾的页面时最近最久未访问的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的LRU代价很高。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220621113011645-165586531113618.png" alt="image-20220621113011645" style="zoom:67%;"><h4 id="最近未使用（NRU）"><a href="#最近未使用（NRU）" class="headerlink" title="最近未使用（NRU）"></a>最近未使用（NRU）</h4><p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R&#x3D;1，当页面被修改时设置 M&#x3D;1。其中 R 位会定时被清零。可以将页面分成以下四类：</p><ul><li>R&#x3D;0，M&#x3D;0</li><li>R&#x3D;0，M&#x3D;1</li><li>R&#x3D;1，M&#x3D;0</li><li>R&#x3D;1，M&#x3D;1</li></ul><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p><p>NRU 优先换出已经被修改的脏页面（R&#x3D;0，M&#x3D;1），而不是被频繁使用的干净页面（R&#x3D;1，M&#x3D;0）。</p><h4 id="先进先出（FIFO）"><a href="#先进先出（FIFO）" class="headerlink" title="先进先出（FIFO）"></a>先进先出（FIFO）</h4><p>选择换出的页面是最先进入的页面。</p><p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p><h4 id="第二次机会算法"><a href="#第二次机会算法" class="headerlink" title="第二次机会算法"></a>第二次机会算法</h4><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p><p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索</p><h4 id="时钟（Clock）"><a href="#时钟（Clock）" class="headerlink" title="时钟（Clock）"></a>时钟（Clock）</h4><p>第二次机会算法需要在链表中移动页面，降低了效率。始终算法使用环形链表将页面连接起来，再使用一个指针指向自老的页面。</p><h3 id="分段"><a href="#分段" class="headerlink" title="分段    *"></a>分段    *</h3><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p><p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220622093752961-165586531113619.png" alt="image-20220622093752961" style="zoom:67%;"><p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p><h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式    *"></a>段页式    *</h3><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p><h3 id="分页与分段的比较"><a href="#分页与分段的比较" class="headerlink" title="分页与分段的比较"></a>分页与分段的比较</h3><ul><li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li><li>地址空间的维度：分页是一维地址空间，分段是二维的。</li><li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li><li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><ul><li><p>盘面（Platter）：一个磁盘有多个盘面；</p></li><li><p>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</p></li><li><p>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</p></li><li><p>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</p></li><li><p>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</p></li><li><p>主轴（Spindle）：使整个盘面转动。</p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220622101834140-165586531113620.png" alt="image-20220622101834140" style="zoom:67%;"></li></ul><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>读写一个磁盘块的时间的影响因素有：</p><ul><li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li><li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li><li>实际的数据传输时间</li></ul><p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p><h4 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h4><p>按照磁盘请求的顺序进行调度。</p><p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p><h4 id="最短寻道时间优先（SSTF）"><a href="#最短寻道时间优先（SSTF）" class="headerlink" title="最短寻道时间优先（SSTF）"></a>最短寻道时间优先（SSTF）</h4><p>优先调度与当前磁头所在磁道距离最近的磁道。</p><p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p><h4 id="电梯算法（SCAN）"><a href="#电梯算法（SCAN）" class="headerlink" title="电梯算法（SCAN）"></a>电梯算法（SCAN）</h4><p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p><p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p><p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h3><p>以下是一个 hello.c 程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, world\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">gcc -o hello hello.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p>这个过程大致如下：</p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220622102350707-165586531113621.png" alt="image-20220622102350707" style="zoom:67%;"><ul><li>预处理阶段：处理以 # 开头的预处理命令；</li><li>编译阶段：翻译成汇编文件；</li><li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li><li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li></ul><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p><ul><li><p>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</p></li><li><p>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220622102607564-165586531113622.png" alt="image-20220622102607564" style="zoom:67%;"></li></ul><h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件    *"></a>目标文件    *</h3><ul><li>可执行目标文件：可以直接在内存中执行；</li><li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li><li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li></ul><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>静态库有以下两个问题：</p><ul><li>当静态库更新时那么整个程序都要重新进行链接；</li><li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li></ul><p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p><ul><li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li><li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li></ul><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220622103045693.png" alt="image-20220622103045693" style="zoom:67%;">]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进程</tag>
      
      <tag>并发</tag>
      
      <tag>异步</tag>
      
      <tag>死锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WEB安全</title>
    <link href="/2022/05/19/WEB%E5%AE%89%E5%85%A8/"/>
    <url>/2022/05/19/WEB%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="WEB安全"><a href="#WEB安全" class="headerlink" title="WEB安全"></a>WEB安全</h1><h2 id="常用漏洞"><a href="#常用漏洞" class="headerlink" title="常用漏洞"></a>常用漏洞</h2><h3 id="CSRF漏洞"><a href="#CSRF漏洞" class="headerlink" title="CSRF漏洞"></a>CSRF漏洞</h3><p><strong>跨站请求伪造</strong>，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</p><p>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</p><p>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</p><p>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</p><p>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下<strong>携带Cookie信息</strong>，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。</p><h4 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h4><ul><li><strong>token谁机制防御</strong>：在请求地址中添加token并验证。要抵御CSRF，关键在于在请求中放入和黑客所不能伪造的信息，并且该信息<strong>不存在于cookie</strong>中。可以在http请求中以参数的形式加入一个<strong>随机产生的token</strong>，并且在服务器端建立一个拦截器来验证这个token值，如果请求中没有token值或者token不正确，则可以认为可能是CSRF攻击而拒绝请求。</li><li><strong>referer值校验</strong>：增加HTTP referer的校验。http协议中，在http头部中有一个字段叫referer，它记录了该<strong>http请求的来源地址</strong>。如果referer记录的不是同一个浏览器的请求，那么久可能是攻击者伪造的恶意链接，可以根据此方法来防范CSRF攻击</li></ul><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>主要形成的原因是在世俗据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的内容拼接到sql语句中后，<strong>被当作sql语句的一部分执行</strong>。从而导致数据库受损等安全问题。即，注入产生的原因是后台服务器接收相关参数<strong>未经过过滤</strong>直接带入数据库查询。</p><h4 id="修复建议-1"><a href="#修复建议-1" class="headerlink" title="修复建议"></a>修复建议</h4><ul><li>对用户提交数据信息进行严格多次的<strong>筛选过滤</strong></li><li>用户内数据内容进行<strong>加密</strong></li><li><strong>代码层</strong>最佳防御sql漏洞方案：采用sql语句<strong>预编译和绑定变量</strong></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h5><p>寻找注入点的本质是找一个需要后台处理后提交给数据库的点，所有的输入<strong>只要和数据库进行交互的</strong>，都可能触发sql注入。</p><p>注入点一般分为三大类</p><ul><li><strong>get</strong>参数触发</li><li><strong>post</strong>参数触发</li><li><strong>cookie</strong>触发</li></ul><p>最简单的方法，引入单引号判断是否存在注入点</p><h5 id="判断是否存在注入"><a href="#判断是否存在注入" class="headerlink" title="判断是否存在注入"></a>判断是否存在注入</h5><p>注入点可否利用与服务端代码和服务器配置息息相关，如<strong>过滤一些危险函数或者限制参数的长度</strong>等，会导致注入难度提升甚至不可利用。</p><ul><li><p><strong>有回显</strong>的注入判断：</p><ul><li>输入单引号，若显示错误则存在sql注入。</li><li>利用逻辑符号判断，参数后加<code>and 1=1</code>或<code>and 1=2</code>，若and 1&#x3D;1页面正常and 1&#x3D;2页面错误，则存在sql注入。同理使用or也可判断。</li></ul></li><li><p><strong>无回显</strong>的注入判断：通过<strong>sleep()<strong>进行判断，若页面返回</strong>符合设置的延迟</strong>，则存在sql注入。（不同数据库有不同的演示函数，需要结合具体情况来使用）</p></li></ul><h5 id="注入类型判断"><a href="#注入类型判断" class="headerlink" title="注入类型判断"></a>注入类型判断</h5><ul><li><p>数字型注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs mysql">select * from table where id=3;<br></code></pre></td></tr></table></figure></li><li><p>字符型注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from table where name=&#x27;admin&#x27;;<br></code></pre></td></tr></table></figure></li></ul><p>需要添加引号去闭合参数的是字符型注入，不需要添加引号的是数字型注入。</p><h5 id="select-1-2-3"><a href="#select-1-2-3" class="headerlink" title="select 1,2,3;"></a>select 1,2,3;</h5><p>如某些网站的参数传递执行的查询有3个字段，但并<strong>不是所有的字段查询结果都会返回</strong>前端的，所以我们需要知道这3个字段中有哪些字段会回显，这个过程相当于找到<strong>数据库与前端显示的通道</strong>。</p><p>执行语句后，通过显示内容就知道哪个数字是这个通道，就可以将这个数字改成问们想查询的内容，结果将会回显到前端。</p><p>如指定数据库的表，即<code>select 1,2,3 from tablename;</code>,返回结果输入数值将替换原来的字段，行数与原数据库表的结构保持一致，即表中有多少行就返回多少行。</p><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h4 id="sql注入万能密码原理"><a href="#sql注入万能密码原理" class="headerlink" title="sql注入万能密码原理"></a>sql注入万能密码原理</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27; or 1=1#</span><br></code></pre></td></tr></table></figure><p>用户登陆界面sql语句一般为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">where</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;user&#x27;</span> <span class="hljs-keyword">and</span> password<span class="hljs-operator">=</span>&quot;pass&quot;;<br></code></pre></td></tr></table></figure><p>当输入正确的账号密码就会返回真值。</p><p>在sql语句中<code>#</code>后的内容将会被省略，输入万能密码后sql语句变为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">where</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span># <span class="hljs-keyword">and</span> password<span class="hljs-operator">=</span>&quot;pass&quot;;<br></code></pre></td></tr></table></figure><p><code>#</code>后的内容被省略，且语句返回为真。</p>]]></content>
    
    
    <categories>
      
      <category>安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后端笔记</title>
    <link href="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>学习路线图</strong></p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/backend-map-16529596795671.png" alt="backend-map" style="zoom: 50%;"><h1 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h1><h2 id="网络是如何工作的"><a href="#网络是如何工作的" class="headerlink" title="网络是如何工作的"></a>网络是如何工作的</h2><h3 id="互联网的解释"><a href="#互联网的解释" class="headerlink" title="互联网的解释"></a>互联网的解释</h3><h4 id="TCP-x2F-IP协议"><a href="#TCP-x2F-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h4><p>​        传输控制协议&#x2F;网际协议（也叫做网络通讯协议），是指能够在不同网络间实现信息传输的协议簇。它是在网络的使用中的最基本的通信协议。TCP&#x2F;IP传输协议对互联网中各部分进行通信的标准和方法进行了规定。并且，TCP&#x2F;IP传输协议是保证网络数据信息及时、完整传输的两个重要的协议。TCP&#x2F;IP传输协议是严格来说是一个四层的体系结构，应用层、传输层、网络层和数据链路层都包含其中。</p><p>​        TCP&#x2F;IP协议是Internet最基本的协议,其中应用层的主要协议有<a href="https://baike.baidu.com/item/Telnet/810597">Telnet</a>、<a href="https://baike.baidu.com/item/FTP/13839">FTP</a>、<a href="https://baike.baidu.com/item/SMTP/175887">SMTP</a>等，是用来接收来自传输层的数据或者按不同应用要求与方式将数据传输至传输层；传输层的主要协议有<a href="https://baike.baidu.com/item/UDP/571511">UDP</a>、TCP，是使用者使用平台和计算机信息网内部数据结合的通道，可以实现数据传输与数据共享；网络层的主要协议有ICMP、IP、IGMP，主要负责网络中数据包的传送等；而网络访问层，也叫网络接口层或数据链路层，主要协议有ARP、<a href="https://baike.baidu.com/item/RARP/610685">RARP</a>，主要功能是提供链路管理错误检测、对不同通信媒介有关信息细节问题进行有效处理等。</p><p>​        TCP&#x2F;IP协议不仅仅值的是TCP和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇，只是因为在该协议中TCP协议和IP协议最具代表性，所以被称为TCP&#x2F;IP协议。</p><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>​        互网络协议地址，又称网际协议地址。</p><p>​        IP地址是IP协议协议&#x2F;131947)提供的一种统一的<a href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F/53569124">地址格式</a>，它为互联网上的每一个网络和每一台<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机</a>分配一个<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/3283849">逻辑地址</a>，以此来屏蔽<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/2901583">物理地址</a>的差异。</p><ul><li><strong>IPv6</strong></li></ul><p>​                当前的互联网标准（IPv4）金允许大约40亿个ip地址，在2019年        11月25日已全部分配完毕。早在1990年IPv6的新标准就以产生，IPv6        允许的唯一地址，确切的数字是39位数，确保世界永远不会再用完。</p><h4 id="W3C-万维网联盟"><a href="#W3C-万维网联盟" class="headerlink" title="W3C(万维网联盟)"></a>W3C(万维网联盟)</h4><p>​        web技术领域最具权威和影响力的国际中立性技术标准机构。W3C发布了多项影响深远的web技术标准及实施指南，如广为业界采用的超文本标记语言HTML（标准通用标记语言下的一个应用），可扩展标记语言XML（标准通用标记语言下的一个子集）等等，有效促进了web技术的互相兼容，对互联网技术的发展和应用起到了基础性和根本性的支撑作用。</p><h4 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h4><p>​        Secure Sockets Layer的缩写，是一系列加密技术，允许 Web 用户保护他们通过 Internet 传输的信息的隐私。</p><p>​        例如谷歌浏览器url地址旁有个锁的图标，该锁应该表明第三方将无法读取您发送或接收的任何信息。在幕后，SSL 通过将您的数据转换为只有接收者知道如何破译的编码消息来实现这一点。如果恶意方正在收听对话，它只会看到看似随机的字符串，而不是您私人信息。</p><h4 id="域名系统（DNS）"><a href="#域名系统（DNS）" class="headerlink" title="域名系统（DNS）"></a>域名系统（DNS）</h4><p>​        它作为将域名和ip地址相互映射的一个分布式数据库，能够是人们更方便地访问互联网。</p><ul><li><p>通用顶级域和国家代码顶级域</p><p>通用顶级域（gTLD），例如.com、.edu、.org、.gov等</p><p>国家代码顶级域（ccTLD）世界上每个国家都有自己的2字母代码。例如，.us、.uk、.cn、.io、.tv</p></li></ul><h3 id="互联网如何运作"><a href="#互联网如何运作" class="headerlink" title="互联网如何运作"></a>互联网如何运作</h3><h4 id="从互联网地址开始"><a href="#从互联网地址开始" class="headerlink" title="从互联网地址开始"></a>从互联网地址开始</h4><p>​        连接到Internet的每台计算机都必须有一个唯一的地址。</p><h4 id="协议栈和数据包"><a href="#协议栈和数据包" class="headerlink" title="协议栈和数据包"></a>协议栈和数据包</h4><p>​        两台计算机想实现互相通信，必须先通过将计算机连接到Internet的人格类型的线路来传输信息。因此，必须将消息从字母文本翻译成电子信号，通过 Internet 传输，然后再翻译回字母文本。该部分<strong>通过使用协议栈</strong>实现 。它通常内置于计算机的操作系统中。由于使用了两种主要的通信协议，因此 Internet 上使用的协议栈被称为 TCP&#x2F;IP 协议栈。</p><p>TCP&#x2F;IP 堆栈如下：</p><table><thead><tr><th>协议层</th><th>注释</th></tr></thead><tbody><tr><td>应用协议层</td><td>特定于应用程序的协议，例如 WWW、电子邮件、FTP 等。</td></tr><tr><td>传输控制协议层</td><td>TCP 使用端口号将数据包定向到计算机上的特定应用程序。</td></tr><tr><td>互联网协议层</td><td>IP 使用 IP 地址将数据包定向到特定计算机。</td></tr><tr><td>硬件层</td><td>将二进制数据包数据转换为网络信号并返回。 （例如以太网网卡、电话线调制解调器等）</td></tr></tbody></table><p>从ip地址为1.2.3.4的计算机到IP地址为5.6.7.8的计算机之间的通信会发生以下过程：</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327103512299-16529596795682.png" alt="image-20220327103512299" style="zoom:50%;"><ol><li><p>该消息将从您计算机上协议堆栈的顶部开始，并向下工作。</p></li><li><p>如果要发送的消息很长，则消息通过的每个堆栈层都可能将消息分解成更小的数据块。这是因为通过 Internet（和大多数计算机网络）发送的数据是以可管理的块的形式发送的。在 Internet 上，这些数据块称为<strong>数据包</strong>。</p></li><li><p>数据包将通过应用层并继续到 TCP 层。每个数据包都分配有一个<strong>端口号</strong>。但足以说明许多程序可能正在使用 TCP&#x2F;IP 堆栈并发送消息。我们需要知道目标计算机上的哪个程序需要接收消息，因为它将监听特定端口。</p></li><li><p>通过 TCP 层后，数据包进入 IP 层。这是每个数据包接收其目标地址 5.6.7.8 的地方。</p></li><li><p>既然我们的消息包有一个端口号和一个 IP 地址，它们就可以通过 Internet 发送了。硬件层负责将包含我们消息的字母文本的数据包转换为电子信号并通过电话线传输它们。</p></li><li><p>在电话线的另一端，您的 ISP 直接连接到 Internet。ISP<strong>路由器</strong>检查每个数据包中的目标地址并确定将其发送到何处。通常，数据包的下一站是另一个路由器。</p></li><li><p>最终，数据包到达计算机 5.6.7.8。在这里，数据包从目标计算机的 TCP&#x2F;IP 堆栈的底部开始并向上工作。</p></li><li><p>随着数据包向上通过堆栈，发送计算机的堆栈添加的所有路由数据（例如 IP 地址和端口号）都会从数据包中剥离。</p></li><li><p>当数据到达栈顶时，数据包被重新组合成原来的形式，“Hello computer 5.6.7.8！”</p></li></ol><h4 id="网络基础设施"><a href="#网络基础设施" class="headerlink" title="网络基础设施"></a>网络基础设施</h4><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327104412823-16529596795683.png" alt="image-20220327104412823" style="zoom:50%;"><p>​        ISP（网络业务提供商） 为其拨入客户维护一个调制解调器池。这由某种形式的计算机（通常是专用计算机）管理，该计算机控制从调制解调器池到主干或专线路由器的数据流。此设置可称为端口服务器，因为它“服务”访问网络。帐单和使用信息通常也在这里收集。</p><p>​        在您的数据包通过电话网络和 ISP 的本地设备后，它们被路由到 ISP 的主干网或 ISP 购买带宽的主干网。从这里开始，数据包通常会经过多个路由器和多个骨干网、专线和其他网络，直到找到它们的目的地，即地址为 5.6.7.8 的计算机。</p><h4 id="互联网基础设施"><a href="#互联网基础设施" class="headerlink" title="互联网基础设施"></a>互联网基础设施</h4><p>​        互联网骨干网由许多相互连接的大型网络组成。这些大型网络被称为<strong>网络服务提供商</strong>或<strong>NSP</strong>。一些大型 NSP 是 UUNet、CerfNet、IBM、BBN Planet、SprintNet、PSINet 等。这些网络相互<strong>对</strong>等以交换数据包流量。每个 NSP 都需要连接到三个 <strong>网络接入点</strong>或<strong>NAP</strong>。在 NAP 处，数据包流量可能会从一个 NSP 的主干跳转到另一个 NSP 的主干。NSP 还在<strong>都会区交易所</strong>或<strong>MAE进行互连</strong>s。MAE 的用途与 NAP 相同，但属于私人所有。NAP 是最初的 Internet 互连点。NAP 和 MAE 都称为 Internet 交换点或<strong>IX</strong>。NSP 还将带宽出售给较小的网络，例如 ISP 和较小的带宽提供商。下图显示了这种分层基础设施。</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327110914707-16529596795684.png" alt="image-20220327110914707" style="zoom: 50%;"><h4 id="Internet路由层次结构"><a href="#Internet路由层次结构" class="headerlink" title="Internet路由层次结构"></a>Internet路由层次结构</h4><p>​        计算机不会知道任何其他计算机在哪里，并且数据包不会发送到每台计算机。用于将数据包送至目的地的信息包含在连接到Internet的每个路由器保存在路由表中。</p><p>​        <strong>路由器是分组交换机。</strong>路由器通常连接在网络之间以在它们之间路由数据包。每个路由器都知道它的子网以及它们使用的 IP 地址。路由器通常不知道它“上方”的 IP 地址。如下图，连接主干的黑匣子是路由器。顶部较大的 NSP 主干通过 NAP 连接。在它们之下是几个子网络，在它们之下是更多的子网络。底部是两个连接有计算机的局域网。</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327111620299-16529596795685.png" alt="image-20220327111620299" style="zoom:50%;"><p>​        当数据包到达路由器时，路由器会检查由始发计算机上的 IP 协议层放置在那里的 IP 地址。路由器检查它的路由表。如果找到包含 IP 地址的网络，则将数据包发送到该网络。如果未找到包含 IP 地址的网络，则路由器将在默认路由上发送数据包，通常沿着骨干层级向上到下一个路由器。希望下一个路由器知道将数据包发送到哪里。如果没有，则数据包再次向上路由，直到到达 NSP 骨干网。连接到 NSP 主干的路由器拥有最大的路由表，在这里数据包将被路由到正确的主干，在那里它将开始“向下”的旅程。</p><h4 id="域名和地址解析"><a href="#域名和地址解析" class="headerlink" title="域名和地址解析"></a>域名和地址解析</h4><p>但是，如果您不知道要连接的计算机的 IP 地址怎么办？您的网络浏览器如何知道这台计算机在 Internet 上的位置？所有这些问题的答案是<strong>域名服务</strong>或 <strong>DNS</strong>。DNS 是一个分布式数据库，用于跟踪 Internet 上的计算机名称及其对应的 IP 地址。</p><p>许多连接到 Internet 的计算机托管 DNS 数据库的一部分以及允许其他人访问它的软件。这些计算机称为 DNS 服务器。没有哪个 DNS 服务器包含整个数据库；它们只包含它的一个子集。如果 DNS 服务器不包含另一台计算机请求的域名，则 DNS 服务器会将请求计算机重定向到另一台 DNS 服务器。</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327112423815-16529596795686.png" alt="image-20220327112423815" style="zoom:50%;"><p>域名服务的结构类似于 IP 路由层次结构。请求名称解析的计算机将被重新定向“向上”层次结构，直到找到可以解析请求中的域名的 DNS 服务器。图 6 说明了层次结构的一部分。树的顶部是域根。在顶部附近可以看到一些较旧、更常见的域。没有显示的是世界各地的众多 DNS 服务器，它们构成了层次结构的其余部分。</p><p>建立 Internet 连接时（例如，对于 LAN 或 Windows 中的拨号网络），通常会在安装过程中指定一个主 DNS 服务器和一个或多个辅助 DNS 服务器。这样，任何需要域名解析的互联网应用程序都可以正常运行。例如，当您在 Web 浏览器中输入网址时，浏览器首先连接到您的主 DNS 服务器。获取您输入的域名的IP地址后，浏览器连接到目标计算机并请求您想要的网页。</p><h4 id="审视互联网协议"><a href="#审视互联网协议" class="headerlink" title="审视互联网协议"></a>审视互联网协议</h4><p>以下将描述Internet上一些重要的常用协议，顺序由高级别得到低级别</p><ul><li><p><strong>应用协议：HTTP和万维网</strong></p><p>​        Internet 上最常用的服务之一是万维网 (WWW)。使 Web 工作的应用程序协议是<strong>超文本传输协议</strong>或<strong>HTTP</strong>。HTTP 是 Web 浏览器和 Web 服务器用于通过 Internet 相互通信的协议。它是一种应用程序级协议，因为它位于协议栈中的 TCP 层之上，并被特定应用程序用来相互通信。在这种情况下，应用程序是 Web 浏览器和 Web 服务器。</p><p>​        HTTP 是一种基于无连接文本的协议。客户端（Web 浏览器）向 Web 服务器发送 Web 元素（例如网页和图像）的请求。请求由服务器处理后，客户端和服务器之间的 Internet 连接断开。必须为每个请求建立一个新连接。大多数协议都是面向连接的。这意味着相互通信的两台计算机通过 Internet 保持连接打开。然而，HTTP 没有。在客户端可以发出 HTTP 请求之前，必须与服务器建立新的连接。</p><p>当您在 Web 浏览器中键入 URL 时，会发生以下情况：</p><ol><li>如果 URL 包含域名，则浏览器首先连接到域名服务器并检索 Web 服务器的相应 IP 地址。</li><li>Web 浏览器连接到 Web 服务器并为所需网页发送 HTTP 请求（通过协议栈）。</li><li>Web 服务器接收请求并检查所需的页面。如果该页面存在，则 Web 服务器将其发送。如果服务器找不到请求的页面，它将发送 HTTP 404 错误消息。</li><li>Web 浏览器收到返回的页面并关闭连接。</li><li>然后浏览器解析页面并寻找完成网页所需的其他页面元素。这些通常包括图像、小程序等。</li><li>对于需要的每个元素，浏览器都会为每个元素向服务器建立额外的连接和 HTTP 请求。</li><li>当浏览器完成加载所有图像、小程序等时，页面将完全加载到浏览器窗口中。</li></ol></li><li><p><strong>应用协议：SMTP和电子邮件</strong></p><p>​        另一种常用的 Internet 服务是电子邮件。电子邮件使用称为<strong>简单邮件传输协议</strong>或 <strong>SMTP</strong>的应用程序级协议。SMTP 也是基于文本的协议，但与 HTTP 不同，SMTP 是面向连接的。SMTP 也比 HTTP 更复杂。SMTP 中的命令和注意事项比 HTTP 中的要多得多。</p><p>当您打开邮件客户端阅读电子邮件时，通常会发生以下情况：</p><ol><li>邮件客户端（Netscape Mail、Lotus Notes、Microsoft Outlook 等）打开到其默认邮件服务器的连接。邮件服务器的 IP 地址或域名通常在安装邮件客户端时设置。</li><li>邮件服务器将始终发送第一条消息以识别自己。</li><li>客户端将发送一个 SMTP HELO 命令，服务器将以 250 OK 消息响应该命令。</li><li>根据客户端是否正在检查邮件、发送邮件等，适当的 SMTP 命令将被发送到服务器，服务器将做出相应的响应。</li><li>此请求&#x2F;响应事务将继续进行，直到客户端发送 SMTP QUIT 命令。然后服务器将说再见并关闭连接。</li></ol><p>下面显示了 SMTP 客户端和 SMTP 服务器之间的简单“对话”。<strong>R：</strong>表示服务器（接收方）发送的消息，<strong>S：</strong>表示客户端（发送方）发送的消息。</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327114242924-16529596795687.png" alt="image-20220327114242924" style="zoom:50%;"><p>此 SMTP 事务取自 RFC 821，它指定了 SMTP。</p></li><li><p><strong>传输控制协议</strong></p><p>​        在协议栈的应用层之下是 TCP 层。当应用程序打开与 Internet 上另一台计算机的连接时，它们发送的消息（使用特定的应用程序层协议）通过堆栈向下传递到 TCP 层。<strong>TCP 负责将应用程序协议路由到目标计算机上的正确应用程序</strong>. 为此，使用端口号。端口可以被认为是每台计算机上的独立通道。例如，您可以一边浏览网页一边阅读电子邮件。这是因为这两个应用程序（Web 浏览器和邮件客户端）使用了不同的端口号。当数据包到达计算机并沿协议栈向上移动时，TCP 层会根据端口号决定哪个应用程序接收数据包。</p><p><strong>TCP 的工作原理</strong>：</p><ul><li>当 TCP 层从上面接收到应用层协议数据时，它会将其分割成可管理的“块”，然后在每个“块”中添加一个带有特定 TCP 信息的 TCP 标头。TCP 标头中包含的信息包括数据需要发送到的应用程序的端口号。</li><li>当 TCP 层从它下面的 IP 层接收到一个数据包时，TCP 层从数据包中剥离 TCP 头数据，必要时进行一些数据重构，然后使用从 TCP 获取的端口号将数据发送到正确的应用程序标题。</li></ul><p>TCP 不是文本协议。<strong>TCP 是一种面向连接的、可靠的字节流服务</strong>。面向连接意味着两个使用 TCP 的应用程序在交换数据之前必须先建立连接。TCP 是可靠的，因为对于接收到的每个数据包，都会向发送方发送确认以确认传送。TCP 还在其标头中包含一个校验和，用于对接收到的数据进行错误检查。TCP 标头如下所示：</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327114608248-16529596795688.png" alt="image-20220327114608248" style="zoom:50%;"><p>​        请注意，TCP 标头中没有 IP 地址的位置。这是因为 TCP 对 IP 地址一无所知。TCP 的工作是可靠地从应用程序到应用程序获取应用程序级数据。从计算机到计算机获取数据的任务是 IP 的工作。</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327114640038-16529596795689.png" alt="image-20220327114640038" style="zoom:50%;"></li><li><p><strong>互联网协议</strong></p><p>​        与 TCP 不同，<strong>IP 是一种不可靠的无连接协议</strong>。IP 不关心数据包是否到达目的地。IP 也不知道连接和端口号。 <strong>IP 的工作也是向其他计算机发送和路由数据包</strong>。IP 数据包是独立的实体，可能无序到达或根本没有到达。确保数据包到达并按正确顺序是 TCP 的工作。IP 与 TCP 唯一的共同点是它接收数据并将其自己的 IP 标头信息添加到 TCP 数据的方式。IP 标头如下所示：</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327114718431-165295967956810.png" alt="image-20220327114718431" style="zoom: 50%;"><p>上面我们在 IP 标头中看到了发送和接收计算机的 IP 地址。下面是一个数据包经过应用层、TCP层和IP层后的样子。应用层数据在 TCP 层进行分段，加上 TCP 包头，包继续到 IP 层，加上 IP 包头，然后包在 Internet 上传输。</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327114739082-165295967956811.png" alt="image-20220327114739082" style="zoom: 50%;"></li></ul><h2 id="DNS以及DNS如何工作"><a href="#DNS以及DNS如何工作" class="headerlink" title="DNS以及DNS如何工作"></a>DNS以及DNS如何工作</h2><h3 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS"></a>什么是DNS</h3><p>域名系统 (DNS) 是 Internet 的电话簿，每台连接到 Internet 的设备都有一个唯一的 IP 地址。Web 浏览器通过Internet 协议 (IP)地址进行交互。DNS 将域名转换为IP 地址，因此浏览器可以加载 Internet 资源。</p><h3 id="DNS如何工作"><a href="#DNS如何工作" class="headerlink" title="DNS如何工作"></a>DNS如何工作</h3><p>DNS 解析过程涉及将主机名（例<a href="http://www.hah3.com)转换为计算机的/">www.hah3.com）转换为计算机的</a> IP 地址（例如 192.168.1.1）。对于 Web 浏览器，DNS 查找发生在“幕后”，除了初始请求外，不需要用户计算机的交互。</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220331171139223-165295967956812.png" alt="image-20220331171139223" style="zoom:67%;"><h4 id="加载网页涉及4个DNS服务器"><a href="#加载网页涉及4个DNS服务器" class="headerlink" title="加载网页涉及4个DNS服务器"></a>加载网页涉及4个DNS服务器</h4><ul><li><p><strong>DNS递归解析器</strong></p><p>又称<strong>DNS解析器</strong>，DNS 解析器是一种服务器，通过 Web 浏览器等应用程序接收来自客户端计算机的查询。DNS解析器是 DNS 查询中的第一站，DNS解析器作为客户端与 DNS 域名服务器的中间人。从 Web 客户端收到 DNS 查询后，<strong>DNS解析器</strong>将使用缓存的数据进行响应，无缓存数据则将向<strong>根域名服务器</strong>发送请求，接着向 <strong>TLD 域名服务器</strong>发送另一个请求，然后向<strong>权威性域名服务器</strong>发送最后一个请求。</p><p>在此过程中，<strong>DNS解析器</strong>将<strong>缓存</strong>从<strong>权威性域名服务器</strong>收到的信息。当一个客户端请求的域名 IP 地址是另一个客户端最近请求的 IP 地址时，解析器可绕过与域名服务器进行通信的过程，并仅从第二个客户端的缓存中为第一个客户端提供所请求的记录。</p></li><li><p><strong>根域名服务器</strong></p><p><strong>ipv4根域名服务器</strong>在全球有13台（1台主根域名服务器，12台辅根域名服务器，13种类型根服务器在全球范围内有多个副本服务器）。<strong>DNS解析器</strong>可以向根域名服务器发送搜寻请求，它们是<strong>DNS解析器</strong>搜寻DNS记录的第一站。<strong>根域名服务器</strong>根据该域的扩展名（.com、.net、.org 等），通过将<strong>DNS解析器</strong>定向到 <strong>TLD 域名服务器</strong>进行响应。</p></li><li><p><strong>TLD域名服务器</strong></p><p><strong>TLD 域名服务器</strong>维护共享通用域扩展名的所有域名的信息，例如 .com、.net 或 url 中最后一个点之后的任何内容。例如，.com <strong>TLD 域名服务器</strong>包含以“.com”结尾的每个网站的信息。如果用户正在搜索 google.com，则在收到来自<strong>根域名服务器</strong>的响应后，<strong>DNS解析器</strong>将向 .com <strong>TLD 域名服务器</strong>发送查询，后者将通过针对该域的<strong>权威性域名服务器</strong>进行响应。</p><p><strong>TLD 域名服务器</strong>的管理由 Internet 编号分配机构（IANA）加以处理，其为 ICANN 的一个分支机构。IANA 将 TLD 服务器分为两个主要组：</p><ul><li><strong>通用顶级域</strong>：这些是非特定国家&#x2F;地区的域，一些最知名的通用 TLD 包括 .com、.org、.net、.edu 和 .gov。</li><li><strong>国家&#x2F;地区代码顶级域</strong>：这些包括特定于某个国家&#x2F;地区或州的任何域。例如，uk、.us、.ru 和 .jp 等。</li></ul></li><li><p><strong>权威域名服务器</strong></p><p><strong>权威性域名服务器</strong>通常是解析器查找 IP 地址过程中的最后一步，如果<strong>权威域名服务器</strong>有权访问所请求的记录，它会将所请求主机名的 IP 地址返回给发出初始请求的 <strong>DNS解析器</strong>。</p></li></ul><h4 id="权威DNS服务器和递归DNS解析器有什么区别"><a href="#权威DNS服务器和递归DNS解析器有什么区别" class="headerlink" title="权威DNS服务器和递归DNS解析器有什么区别"></a>权威DNS服务器和递归DNS解析器有什么区别</h4><p>两种服务器都执行不同的角色并位于 DNS 查询管道内的不同位置</p><ul><li><p><strong>递归DNS解析器</strong><br><strong>DNS解析器</strong>是响应来自客户端的递归请求并花时间跟踪DNS 记录的计算机。它通过发出一系列请求来完成此操作，直到它到达所请求记录的<strong>权威 DNS 域名服务器</strong>（如果未找到记录，则超时或返回错误）。<strong>DNS 解析器</strong>并不总是需要发出多个请求来跟踪响应客户端所需的记录。<strong>缓存</strong>是一个数据持久性过程，它通过在 DNS 查找中更早地提供请求的资源记录来帮助缩短必要的请求。</p></li><li><p><strong>权威DNS服务器</strong><br><strong>权威 DNS 服务器</strong>是实际保存并负责 DNS 资源记录的服务器。这是位于 DNS 查找链底部的服务器，它将<strong>响应查询的资源记录</strong>，最终允许发出请求的 Web 浏览器到达访问网站或其他 Web 资源所需的 <strong>IP 地址</strong>。</p><p>在查询是针对<strong>子域</strong>的情况下，将在<strong>权威名称服务器</strong>之后的序列中添加一个额外的域名服务器，该域名服务器负责存储子域的CNAME 记录。</p></li></ul><h4 id="DNS查找的步骤"><a href="#DNS查找的步骤" class="headerlink" title="DNS查找的步骤"></a>DNS查找的步骤</h4><p>注意：DNS 查找信息通常会在查询计算机中<strong>本地缓存</strong>或在 <strong>DNS 基础结构中远程缓存</strong>。<strong>DNS 查找</strong>通常有 <strong>8</strong> 个步骤。<strong>有缓存 DNS 信息时，会跳过 DNS 查找过程中的步骤</strong>，从而使其更快。下面的示例概述了没有缓存时的所有 8 个步骤。</p><ol><li><p>用户在 Web 浏览器中键入“google.com”，查询进入 Internet 并由 <strong>DNS 递归解析器</strong>接收。</p></li><li><p>然后解析器查询 <strong>DNS 根名称服务器</strong> (.)。</p></li><li><p>然后，<strong>根服务器</strong>使用顶级域 <strong>(TLD) DNS 服务器</strong>（例如 .com 或 .net）的地址响应<strong>解析器</strong>，该服务器存储其域的信息。在搜索 google.com 时，我们的请求指向 .com TLD。</p></li><li><p>然后<strong>解析器</strong>向 .com <strong>TLD</strong> 发出请求。</p></li><li><p>然后，<strong>TLD 服务器</strong>使用域名称服务器 google.com 的 IP 地址进行响应。</p></li><li><p>最后，<strong>递归解析器</strong>向域的<strong>域名服务器</strong>发送查询。</p></li><li><p>然后 google.com 的 IP 地址从<strong>域名服务器</strong>返回到<strong>解析器</strong>。</p></li><li><p>然后 <strong>DNS 解析器</strong>使用最初请求的域的 IP 地址响应 Web 浏览器。</p></li><li><p>一旦 DNS 查找的 8 个步骤返回了 google.com 的 IP 地址，浏览器就能够发出对网页的请求（查询结束）。</p></li><li><p>浏览器向 IP 地址发出<a href="https://www.cloudflare.com/learning/ddos/glossary/hypertext-transfer-protocol-http/">HTTP</a>请求。</p></li><li><p>该 IP 上的服务器返回要在浏览器中呈现的网页。</p></li></ol><h3 id="什么是DNS解析器"><a href="#什么是DNS解析器" class="headerlink" title="什么是DNS解析器"></a>什么是DNS解析器</h3><p>DNS 解析器是 DNS 查找的第一站，它负责处理发出初始请求的客户端。解析器启动一系列查询，最终将 URL 转换为必要的 IP 地址。</p><p>注意：典型的未缓存 DNS 查找将涉及递归和迭代查询。</p><p>区分递归DNS查询和递归 DNS 解析器非常重要。查询是指向需要解析查询的 DNS 解析器发出的请求。DNS递归解析器是接受递归查询并通过发出必要请求来处理响应的计算机。</p><h3 id="DNS查询的类型有哪些"><a href="#DNS查询的类型有哪些" class="headerlink" title="DNS查询的类型有哪些"></a>DNS查询的类型有哪些</h3><p>在典型的 DNS 查找中，会发生三种类型的查询。通过使用这些查询的组合，DNS 解析的优化过程可以减少行进的距离。在理想情况下，缓存记录数据将可用，允许 DNS 域名服务器返回非递归查询。</p><h4 id="3种类型的DNS查询："><a href="#3种类型的DNS查询：" class="headerlink" title="3种类型的DNS查询："></a>3种类型的DNS查询：</h4><ol><li><strong>递归查询</strong>- 在递归查询中，DNS 客户端要求 DNS 服务器（通常是 DNS 递归解析器）以请求的资源记录或解析器找不到记录时的错误消息响应客户端。</li><li><strong>迭代查询</strong>- 在这种情况下，DNS 客户端将允许 DNS 服务器返回它可以返回的最佳答案。如果被查询的 DNS 服务器与查询名称<strong>不匹配</strong>，它将返回一个对域名称空间较低级别的<strong>权威 DNS 服务器</strong>的引用。然后，DNS 客户端将对引用地址进行查询。此过程将继续使用查询链中的其他 DNS 服务器，直到发生错误或超时。</li><li><strong>非递归查询</strong>- 这通常会在 DNS 解析器客户端向 DNS 服务器查询它有权访问的记录时发生，因为它对记录具有权威性，或者记录存在于其缓存中。通常，DNS 服务器会缓存 DNS 记录，以防止额外的带宽消耗和上游服务器的负载。</li></ol><h3 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h3><p>缓存的目的是将数据临时存储在一个位置，从而提高数据请求的性能和可靠性。DNS 缓存涉及将数据存储在<strong>更靠近请求客户端的位置</strong>，以便可以<strong>更早地解析 DNS 查询</strong>，并且可以<strong>避免 DNS 查找链下游的额外查询</strong>，从而<strong>缩短加载时间并减少带宽&#x2F;CPU 消耗</strong>。DNS 数据可以缓存在多个位置，每个位置都将存储 DNS 记录一段由生存时间 (TTL，是指数据包在被路由器丢弃之前被设置为存在于网络中的时间或“跳数”) 确定的时间。</p><ul><li><p><strong>浏览器DNS缓存</strong><br>现代 Web 浏览器默认设计为<strong>在一定时间内缓存 DNS 记录</strong>。目的很明显，<strong>DNS 缓存越靠近 Web 浏览器，必须采取的处理步骤就越少</strong>，以便检查缓存并向 IP 地址发出正确的请求。<strong>当请求 DNS 记录时，浏览器缓存是为请求的记录检查的第一个位置</strong>。</p></li><li><p><strong>操作系统（os）级别的DNS缓存</strong><br>操作系统级别的 DNS 解析器是 DNS 查询<strong>离开您的计算机之前的第二个也是最后一个本地站点</strong>。操作系统内部在处理此查询的进程通常称为<strong>“存根解析器”</strong>或 <strong>DNS 客户端</strong>。当存根解析器从应用程序收到请求时，它首先检查自己的缓存以查看是否有记录。如果没有，它会在本地网络外部向 Internet 服务提供商 (ISP) 内部的 DNS 递归解析器发送一个 DNS 查询（设置了递归标志）。</p><p>当 ISP 内部的递归解析器接收到 DNS 查询时，与之前的所有步骤一样，它还将检查请求的主机到 IP 地址的转换是否已存储在其本地持久层内。</p><p>递归解析器还具有其他功能，具体取决于其<strong>缓存中的记录类型</strong>：</p><ol><li>如果解析器没有<strong>A 记录</strong>，但有权威名称服务器的<strong>NS 记录</strong>，它将直接查询这些名称服务器，绕过 DNS 查询中的几个步骤。此快捷方式可防止从根和 .com 名称服务器（在我们搜索 google.com 中）进行查找，并有助于更快地解析 DNS 查询。</li><li>如果解析器没有 NS 记录，它将向 TLD 服务器（在我们的例子中为 .com）发送查询，跳过根服务器。</li><li>万一解析器没有指向 TLD 服务器的记录，它将查询根服务器。此事件通常在清除 DNS 缓存后发生。</li></ol></li></ul><h2 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP"></a>什么是HTTP</h2><p><strong>超文本传输协议</strong> (HTTP) 是万维网的基础，用于使用超文本链接加载网页。HTTP 是一种<strong>应用层</strong>协议，旨在在联网设备之间传输信息，并在网络协议栈的其他层之上运行。HTTP 上的典型流程涉及客户端机器向服务器发出请求，然后服务器发送响应消息。</p><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>HTTP 请求是互联网通信平台（如 Web 浏览器）请求加载网站所需信息的方式。</p><p>通过 Internet 发出的每个 HTTP 请求都带有一系列编码数据，这些数据携带不同类型的信息。一个典型的 HTTP 请求包含：</p><ol><li><strong>HTTP 版本类型</strong></li><li><strong>一个网址</strong></li><li><strong>HTTP 方法</strong></li><li><strong>HTTP 请求标头</strong></li><li><strong>可选的 HTTP 正文。</strong></li></ol><h4 id="什么是HTTP方法"><a href="#什么是HTTP方法" class="headerlink" title="什么是HTTP方法"></a>什么是HTTP方法</h4><p><strong>指示 HTTP 请求期望从查询的服务器获得的操作</strong>。例如，两种最常见的 HTTP 方法是“GET”和“POST”；<strong>“GET”请求期望返回信息</strong>（通常以网站的形式），而<strong>“POST”请求通常表明客户端正在向 Web 服务器提交信息</strong>（例如表单信息，例如提交的用户名和密码）。</p><h4 id="什么是HTTP请求标头"><a href="#什么是HTTP请求标头" class="headerlink" title="什么是HTTP请求标头"></a>什么是HTTP请求标头</h4><p>HTTP 标头包含<strong>存储在键值对中的文本信息</strong>，它们包含在每个 HTTP 请求（和响应）中。这些标头传达核心信息，例如<strong>客户端正在使用什么浏览器，正在请求什么数据</strong>。</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220401135618143-165295967956813.png" alt="image-20220401135618143" style="zoom: 33%;"><h4 id="HTTP请求正文中有什么"><a href="#HTTP请求正文中有什么" class="headerlink" title="HTTP请求正文中有什么"></a>HTTP请求正文中有什么</h4><p>请求的主体是包含请求正在传输的信息的“主体”的部分。<strong>HTTP 请求的正文包含提交给 Web 服务器的任何信息</strong>，例如用户名和密码，或输入到表单中的任何其他数据。</p><h3 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h3><p>HTTP 响应是 <strong>Web 客户端（通常是浏览器）从 Internet 服务器接收的响应 HTTP 请求的内容</strong>。这些响应根据 HTTP 请求中的要求传达有价值的信息。</p><p>典型的 HTTP 响应包含：</p><ol><li><strong>HTTP 状态码</strong></li><li><strong>HTTP 响应标头</strong></li><li><strong>可选的 HTTP 正文</strong></li></ol><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><ol><li><p>HTTP 状态代码是最常用于指示 HTTP 请求是否已成功完成的 3 位代码。状态码分为以下 5 个块：</p></li><li><ol><li><strong>1xx 信息</strong></li><li><strong>2xx 成功</strong></li><li><strong>3xx 重定向</strong></li><li><strong>4xx 客户端错误</strong></li><li><strong>5xx 服务器错误</strong></li></ol></li><li><ol><li><p>“xx”指的是 00 到 99 之间的不同数字。</p></li><li><p>以数字“2”开头的状态代码表示成功。例如，客户端请求网页后，最常见的响应状态码为“200 OK”，表示请求已正确完成。</p></li><li><p>如果响应以“4”或“5”开头，则表示出现错误，网页将不会显示。<strong>以“4”开头的状态代码表示客户端错误</strong>（在 URL 中打错字时遇到“404 NOT FOUND”状态代码是很常见的）。<strong>以“5”开头的状态码表示服务器端出现问题</strong>。状态代码也可以以“1”或“3”开头，分别表示信息响应和重定向。</p></li></ol></li></ol><h4 id="HTTP响应标头"><a href="#HTTP响应标头" class="headerlink" title="HTTP响应标头"></a>HTTP响应标头</h4><p>与HTTP 请求非常相似，HTTP 响应带有传达重要信息的标头，例如在响应正文中发送的数据的语言和格式。</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220401204539200-165295967956814.png" alt="image-20220401204539200" style="zoom:50%;"><h4 id="HTTP响应文正内容"><a href="#HTTP响应文正内容" class="headerlink" title="HTTP响应文正内容"></a>HTTP响应文正内容</h4><p>对“GET”请求的成功 HTTP 响应通常具有包含<strong>请求信息的正文</strong>。在大多数 Web 请求中，这是 Web 浏览器将其转换为网页的 HTML 数据。</p><h1 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h1><h2 id="互联网-1"><a href="#互联网-1" class="headerlink" title="互联网"></a>互联网</h2><h3 id="A记录"><a href="#A记录" class="headerlink" title="A记录"></a>A记录</h3><p>“A”代表“地址”，这是最基础的 DNS记录类型：它表示给定域的 IP 地址。比如，拉取 cloudflare.com 的 DNS 记录，A 记录当前返回的 IP 地址为：104.17.210.9。</p><p>A 记录只保存 IPv4 地址。如果一个网站拥有 IPv6 地址，它将改用“AAAA”记录。</p><h3 id="DNS-NS记录"><a href="#DNS-NS记录" class="headerlink" title="DNS NS记录"></a>DNS NS记录</h3><p>NS 代表“域名服务器”，域名服务器记录指示哪个 DNS 服务器对该域具有权威性（即，哪个服务器包含实际 DNS 记录）。基本上，NS 记录告诉互联网可从哪里找到域的 IP 地址。一个域通常会有多个 NS 记录，这些记录可指示该域的主要和辅助域名服务器。倘若没有正确配置的 NS 记录，用户将无法加载网站或应用程序。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySql笔记</title>
    <link href="/2022/03/16/MySql%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/16/MySql%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="启动MySQL："><a href="#启动MySQL：" class="headerlink" title="启动MySQL："></a>启动MySQL：</h4><p> mysql -u(用户名) -p(明文密码)    （-p后可以不写密码直接回车就可以输入不是明文的密码）</p><h2 id="数据库操作："><a href="#数据库操作：" class="headerlink" title="数据库操作："></a>数据库操作：</h2><ul><li><p>查看所有数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs mysql">show databases;<br></code></pre></td></tr></table></figure></li><li><p>查看当前使用的数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select database();<br></code></pre></td></tr></table></figure></li><li><p>创建数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create databases 数据库名 charset-utf8;<br></code></pre></td></tr></table></figure></li><li><p>删除数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop database 数据库名;<br></code></pre></td></tr></table></figure></li><li><p>使用数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use database 数据库名;<br></code></pre></td></tr></table></figure></li><li><p>查看数据库中所有表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show tables;<br></code></pre></td></tr></table></figure></li></ul><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><ul><li><p>查看表结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">desc 表名;<br></code></pre></td></tr></table></figure></li><li><p>创建表结构的语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名(字段名 数据类型 可选的约束条件);<br>例：<br>create table TableName(id int unsigned auto_increment primary key not null,name varchar(10));<br></code></pre></td></tr></table></figure><p>创建了两个列，分别是int类型 id，字符串类型name</p><ul><li>int类型 id</li><li>unsigned 为“无符号”的意思。unsigned即为非负数，用此类型可以增加数据长度。</li><li>auto_increment 自增长</li><li>primary key 主键</li><li>not null 非空</li></ul></li><li><p>修改表–添加字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table 表名 add 列名 类型;<br>例：<br>alter table TableName add NowTime datetime;<br></code></pre></td></tr></table></figure></li><li><p>修改表–修改字段–不重命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table 表名 modify 列名 类型及约束;<br>例：<br>alter table TableName modify date nout noll;<br></code></pre></td></tr></table></figure></li><li><p>删除表–删除字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table 表名 drop 列名;<br>例：<br>alter table TableName drop NowTime;<br></code></pre></td></tr></table></figure></li><li><p>删除表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop table 表名;<br>例：<br>drop table TableName;<br></code></pre></td></tr></table></figure></li><li><p>查看表的创建语句–详细过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show create table 表名;<br>例：<br>show create table TableName;<br></code></pre></td></tr></table></figure></li></ul><h2 id="查询基本使用"><a href="#查询基本使用" class="headerlink" title="查询基本使用"></a>查询基本使用</h2><ul><li><p>查询所有列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from 表名;<br>例:<br>select * from TableName;<br></code></pre></td></tr></table></figure></li><li><p>查询指定列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列1，列2， ...from 表名;<br>例：<br>select id, name from TableName;<br></code></pre></td></tr></table></figure></li></ul><h2 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h2><p>说明：主键列是自动增长，但是在全列插入时需要占位，通常使用空值(0或者null);字段默认 值default 来占位，插入成功后以实际数据为准  </p><ul><li><p><strong>全列插入</strong>：值的顺序与表结构字段的顺序完全一一对应，此时字段名列表不用填写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into 表名 values(...);<br>例：<br>insert into TableName values(0,&#x27;name&#x27;,&#x27;2022-3-16&#x27;);<br></code></pre></td></tr></table></figure></li><li><p><strong>部分列插入</strong>：值的顺序与给出的列顺序对应，此时需要根据实际的数据的特点填写对应字段列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into 表名 (列1, ...) values(值1, ...);<br>例：<br>insert into students(id,name,NowTime )values(1,&#x27;name2&#x27;,&#x27;2022-3-16&#x27;);<br></code></pre></td></tr></table></figure><p>上面的语句一次可以向表中插入一行数据，还可以一次性插入多行数据，这样可以减少与数据库的通信。</p></li><li><p><strong>全列多行插入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into 表名 values(...),(...)...;<br>例：<br>insert into TableName values(0, &#x27;result1&#x27;),(0, &#x27;result2&#x27;);<br></code></pre></td></tr></table></figure></li><li><p><strong>部分列多行插入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into 表名(列1,...) values(值1,...),(值1,...)...;<br>例：<br>insert into TableName(name) values(&#x27;result1&#x27;),(&#x27;result2&#x27;),(&#x27;result3&#x27;);<br></code></pre></td></tr></table></figure></li><li><p><strong>修改</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update 表名 set 列1=值1,列2=值2... where 条件;<br>例：<br>update TableName set name=&#x27;new name&#x27;,NowTime=&#x27;2022-3-17&#x27; where id=3;<br></code></pre></td></tr></table></figure><p>修改id等于3的name和NowTime值</p></li><li><p><strong>删除</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from 表名 where 条件;<br>例：<br>delete from TableName where id=5;<br></code></pre></td></tr></table></figure></li><li><p><strong>as关键字</strong>：</p><ul><li><p>使用as给字段起别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select id as 序号,name as 名字, NowTime as 当前时间 from TableName;<br></code></pre></td></tr></table></figure></li><li><p>可以通过as给表起别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select t.id,t.name,t.NowTime from TableName as t;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="条件语句查询"><a href="#条件语句查询" class="headerlink" title="条件语句查询"></a>条件语句查询</h2><ul><li>where 后面支持多种运算符，进行条件的处理  </li><li>比较运算符  </li><li>逻辑运算符  </li><li>模糊查询  </li><li>范围查询  </li><li>空判断</li></ul><h4 id="比较运算符："><a href="#比较运算符：" class="headerlink" title="比较运算符："></a>比较运算符：</h4><ul><li><p>等于：&#x3D; </p></li><li><p>大于：&gt;  </p></li><li><p>大于等于：&gt;&#x3D;  </p></li><li><p>小于：&lt;  </p></li><li><p>小于等于：&lt;  </p></li><li><p>不等于：!&#x3D;</p></li><li><p>或&lt;  </p></li><li><p>例1：查询编号大于3的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where id 3;<br></code></pre></td></tr></table></figure></li><li><p>例2：查询编号不大于4的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where id &lt; 4;<br></code></pre></td></tr></table></figure></li><li><p>例3：查询姓名不是“黄蓉”的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where name !=黄蓉&#x27;;<br></code></pre></td></tr></table></figure></li><li><p>例4：查询没被删除的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where is delete=0;<br></code></pre></td></tr></table></figure></li></ul><h4 id="逻辑运算符："><a href="#逻辑运算符：" class="headerlink" title="逻辑运算符："></a>逻辑运算符：</h4><ul><li><p>and</p></li><li><p>or</p></li><li><p>not</p></li><li><p>例5：查询编号大于3的女同学  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where id 3 and gender=0;<br></code></pre></td></tr></table></figure></li><li><p>例6：查询编号小于4或没被删除的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where id 4 or is delete=0; <br></code></pre></td></tr></table></figure></li></ul><h4 id="模糊查询："><a href="#模糊查询：" class="headerlink" title="模糊查询："></a>模糊查询：</h4><ul><li><p>like</p></li><li><p>%（表示任意多个任意字符）</p></li><li><p>_（表示一个任意字符）</p></li><li><p>例7：查询姓黄的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where name like &#x27;黄%&#x27;;<br></code></pre></td></tr></table></figure></li><li><p>例8：查询姓黄并且“名”是一个字的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where name like &#x27;黄_&#x27;;<br></code></pre></td></tr></table></figure></li><li><p>例9：查询姓黄或叫靖的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where name like &#x27;黄%&#x27; or name like &#x27;%靖&#x27;;<br></code></pre></td></tr></table></figure></li></ul><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>范围查询分为连续范围查询和非连续范围查询 ,in表示在一个非连续的范围内  </p><ul><li><p>例10：查询编号是1或3或8的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where id in(1,3,8);<br></code></pre></td></tr></table></figure><p>betweer ..ad.表示在一个连续的范围内  </p></li><li><p>例11：查询编号为3至8的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where id between 3 and 8;<br></code></pre></td></tr></table></figure></li><li><p>例12：查询编号是3至8的男生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where (id between 3 and 8) and gender=1;<br></code></pre></td></tr></table></figure></li></ul><h4 id="空判断"><a href="#空判断" class="headerlink" title="空判断"></a>空判断</h4><p>判断为空</p><ul><li><p>例13：查询没有填写身高的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where height is null;  <br></code></pre></td></tr></table></figure><p>注意：1.null与是不同的2.is null   </p><p>判非空is not null</p></li><li><p>例14：查询填写了身高的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where height is not null;  <br></code></pre></td></tr></table></figure></li><li><p>例15：查询填写了身高的男生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where height is not null and gender=1<br></code></pre></td></tr></table></figure></li><li><p>优先级：</p><p>优先级由高到低的顺序为：小括号，not，比较运算符，逻辑运算符and比or先运算，如果同时出现并希望先运算or，需要结合()使用</p></li></ul><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul><li><p>排序查询语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...];<br></code></pre></td></tr></table></figure></li><li><p>语法说明：</p><p>将行数据按照列1进行排序，如果某些行列1的值相同时，则按照列2排序，以此类推  </p><p>asc从小到大排列，即升序  </p><p>desc从大到小排序，即降序  </p><p>默认按照列值从小到大排列（即asc关键字）</p></li><li><p>例1：查询未删除男生信息，按学号降序  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where gender= 1 and is delete= 0 order by id desc; <br></code></pre></td></tr></table></figure></li><li><p>例2：查询未删除学生信息，按名称升序  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where is delete= 0 order by name;<br></code></pre></td></tr></table></figure></li><li><p>例3：显示所有的学生信息，先按照年龄从大-&gt;小排序，当年龄相同时按照身高从高-&gt;矮排 序  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students order by age desc, height desc;<br></code></pre></td></tr></table></figure></li></ul><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from 表名 limit start=0,count;<br></code></pre></td></tr></table></figure><p>说明：</p><p>从start 开始，获取count 条数据  </p><p>start 默认值为0  </p><p>也就是当用户需要获取数据的前n条的时候可以直接写上 xxx limit n;</p><ul><li><p>例：查询前3行男生信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where gender=1 limit 0,3;<br></code></pre></td></tr></table></figure><p>已知：每页显示m条数据，当前显示第n页</p><p>求总页数：此段逻辑后面会在python项目中实现  </p><p>查询总条数p1  </p><p>使用p1除以m得到p2  </p><p>如果整除则p2为总数页  </p><p>如果不整除则p2+1为总页数  </p><p>获取第n页的数据的SQL语句求解思路  </p><p>第n页前有n-1页  </p><p>所在第n页前已经显示的数据的总量是(n-1)*m </p><p>*由于数据的下标从0开始所以第n页前所有的网页的下标是 0,1,…,(n-1)*m-1</p><p>所以第n页的数据起始下标是(n-1)*m</p><p>获取第n页数据的SQL语句</p><p>select * from students where is_delete&#x3D;0 limit (n-1)*m,m   </p><p>注意：在sql语句中limit 后不可以直接加公式</p></li></ul><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p>总数</p><p>count(*)表示计算总行数，括号中写星与列号，结果是相同的</p><ul><li><p>例1：查询学生总数  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select count(*) from students; <br></code></pre></td></tr></table></figure><p>最大值  </p><p>max(列)表示求此列的最大值  </p></li><li><p>例2：查询女生的编号最大值  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select max(id) from students where gender=2;  <br></code></pre></td></tr></table></figure><p>最小值  </p><p>min(列)表示求此列的最小值  </p></li><li><p>例3：查询未删除的学生最小编号  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select min( id) from students where is_delete=0;<br></code></pre></td></tr></table></figure><p>求和  </p><p>sum(列)表示求此列的和</p></li><li><p>例4：查询男生的总年龄  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select sum(age) from students where gender=1;<br></code></pre></td></tr></table></figure><p>平均年龄  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select sum(age)/count(*) from students where gender=1;<br></code></pre></td></tr></table></figure><p>平均值  </p><p>avg(列)表示求此列的平均值  </p></li><li><p>例5：查询未删除女生的编号平均值  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select avg(id) from students where is_delete= 0 and gender=2;<br></code></pre></td></tr></table></figure></li></ul><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>group by   </p><p>group by + group concat()  </p><p>group_concat(字段名)根据分组结果，使用group _concat()来放置每一个分组中某字段的集合  </p><p>group by +聚合函数  </p><p>通过group_concat 的启发，我们既然可以统计出每个分组的某字段的值的集合，那么我们 也可以通过集合函数来对这个值的集合做一些操作  </p><p>group by + having   </p><p>having 条件表达式：用来过滤分组结果  </p><p>having 作用和lwhere 类似，但having只能用于group by 而where,是用来过滤表数据 </p><p>group by + with rollup   </p><p>with rollupl 的作用是：在最后新增一行，来记录当前表中该字段对应的操作结果，一般是汇总结果  </p><p>连接查询语法</p><p>对于外连接outer 关键字可以省略  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from 表1 inner或left或right join 表2 on 表1.列 运算符 表2.列;<br></code></pre></td></tr></table></figure><ul><li><p>例1：使用内连接查询班级表与学生表  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students inner join classes on students.cls_id = classes.id;<br></code></pre></td></tr></table></figure></li><li><p>例2：使用左连接查询班级表与学生表  </p><p>此处使用了as为表起别名，目的是编写简单  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students as s left join classes as c on s.cls_id = c.id;<br></code></pre></td></tr></table></figure></li><li><p>例3：使用右连接查询班级表与学生表  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students as s right join classes as c on s.cls_id c.id;<br></code></pre></td></tr></table></figure></li><li><p>例4：查询学生姓名及班级名称  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select s.name,c.name from students as s inner join classes as c on s.cls_id = c.id<br></code></pre></td></tr></table></figure></li></ul><p>子查询：</p><p>在一个select 语句中，嵌入了另外一个select 语句，那么被嵌入的select语句称之为子查询语句，外部那个select语句则称为主查询  </p><p>主查询和子查询的关系  </p><p>子查询是嵌入到主查询中  </p><p>子查询是辅助主查询的要么充当条件要么充当数据源  </p><p>子查询是可以独立存在的语句是一条完整的select 语句  </p><p>标量子查询  </p><p>查询班级学生平均年龄  </p><p>查询大于平均年龄的学生  </p><p>查询班级学生的平均身高  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where age &gt; (select avg(age) from students);<br></code></pre></td></tr></table></figure><p>列级子查询  </p><p>查询还有学生在班的所有班级名字</p><p>查询还有学生在班的所有班级名字  </p><p>找出学生表中所有的班级id </p><p>找出班级表中对应的名字  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select name from classes where id in (select cls_id from students);<br></code></pre></td></tr></table></figure><p>行级子查询  </p><p>需求：查找班级年龄最大身高最高的学生  </p><p>行元素：将多个字段合成一个行元素在行级子查询中会使用到行元素  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where (height,age) = (select max(height),max(age) from students);<br></code></pre></td></tr></table></figure><h4 id="UNION操作符"><a href="#UNION操作符" class="headerlink" title="UNION操作符"></a>UNION操作符</h4><p><strong>用于合并两个或多个 SELECT 语句的结果集。</strong></p><p>UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。</p><p>以下为不同的两个表中的country列</p><img src="/2022/03/16/MySql%E7%AC%94%E8%AE%B0/image-20220518182203683.png" alt="image-20220518182203683" style="zoom:67%;"><img src="/2022/03/16/MySql%E7%AC%94%E8%AE%B0/image-20220518182226084.png" alt="image-20220518182226084" style="zoom:67%;"><p>执行语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT country FROM Websites<br>UNION<br>SELECT country FROM apps<br>ORDER BY country;<br></code></pre></td></tr></table></figure><img src="/2022/03/16/MySql%E7%AC%94%E8%AE%B0/image-20220518182336814.png" alt="image-20220518182336814" style="zoom:67%;"><p>UNION指挥选取把不同的值，若想选取重复的值可使用UNION ALL</p><p>执行语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT country FROM Websites<br>UNION ALL<br>SELECT country FROM apps<br>ORDER BY country;<br></code></pre></td></tr></table></figure><img src="/2022/03/16/MySql%E7%AC%94%E8%AE%B0/image-20220518182531589.png" alt="image-20220518182531589" style="zoom:67%;"><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>用于限制查询结果返回的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from tablename limit i,nl<br></code></pre></td></tr></table></figure><ul><li>i：查询结果的索引值，即从0开始查找</li><li>n：查询结果返回的数量</li></ul><h4 id="information-schema-schemata"><a href="#information-schema-schemata" class="headerlink" title="information_schema.schemata"></a>information_schema.schemata</h4><p>获取所有数据库信息</p><img src="/2022/03/16/MySql%E7%AC%94%E8%AE%B0/image-20220519172542302.png" alt="image-20220519172542302" style="zoom:67%;"><h4 id="group-concat"><a href="#group-concat" class="headerlink" title="group_concat()"></a>group_concat()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select group_concat(column) from tablename;<br></code></pre></td></tr></table></figure><p>将相同字段在同一行显示</p><img src="/2022/03/16/MySql%E7%AC%94%E8%AE%B0/image-20220519173003658.png" alt="image-20220519173003658" style="zoom:67%;"><h4 id="select-查询某数据库表名"><a href="#select-查询某数据库表名" class="headerlink" title="select 查询某数据库表名"></a>select 查询某数据库表名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select table_name from information_schema.tables where table_schema=&#x27;test&#x27;;<br></code></pre></td></tr></table></figure><p>以上查询返回<strong>test数据库</strong>中的所有表</p><h4 id="select-查询表中的字段名"><a href="#select-查询表中的字段名" class="headerlink" title="select 查询表中的字段名"></a>select 查询表中的字段名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select column_name from information_schema.columns where table_name=&#x27;test&#x27;;<br></code></pre></td></tr></table></figure><p>以上返回<strong>test表</strong>中的所有字段名</p><h4 id="不使用use进入数据库，获取该数据库数据"><a href="#不使用use进入数据库，获取该数据库数据" class="headerlink" title="不使用use进入数据库，获取该数据库数据"></a>不使用use进入数据库，获取该数据库数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from database.table;<br></code></pre></td></tr></table></figure><p>database.table：数据库名.表名</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>有时候添加数据会显示语法错误，可能是因为添加的数据与其语法重名，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table gotodata add repeat varchar(100);//显示语法错误，因为repeat与语法重名<br>alter table gotodata add `repeat` varchar(100);//正确输入，使用反引号<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用hexo+Github搭建博客</title>
    <link href="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p><strong>环境需要</strong>：nodejs，git，hexo</p><p>下载安装nodejs，git</p><h2 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h2><ul><li><p>设置密钥</p><p>打开git bash</p></li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs jboss-cli">git config <span class="hljs-params">--global</span> user.name <span class="hljs-string">&quot;wuhahe&quot;</span><span class="hljs-comment"># 设置用户名</span><br>git config <span class="hljs-params">--global</span> user.email <span class="hljs-string">&quot;529516310@qq.com&quot;</span><span class="hljs-comment"># 设置用户名邮箱</span><br>git config <span class="hljs-params">--list</span><br></code></pre></td></tr></table></figure><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220303222320461.png" alt="image-20220303222320461" style="zoom: 50%;"><p>​        继续输入命令，修改邮箱</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;529516310@qq.com&quot;</span><br></code></pre></td></tr></table></figure><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220303222620044.png" alt="image-20220303222620044" style="zoom: 50%;"><p>​        进入.ssh文件夹，打开id_rsa.pub，全选复制密钥</p><ul><li><p>配置github</p><p>依次进入settings \ SSH and GPGkeys 点击New SSH key添加</p></li></ul><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220303223100169.png" alt="image-20220303223100169" style="zoom: 33%;"><p>​        设置完成！</p><h2 id="安装与使用hexo"><a href="#安装与使用hexo" class="headerlink" title="安装与使用hexo"></a><strong>安装与使用hexo</strong></h2><p><strong>下载安装hexo</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g hexo<br></code></pre></td></tr></table></figure><p>创建blog文件夹，用git打开hexo子文件夹，未来该文件夹用来存放代码。</p><ul><li><strong>初始化：</strong></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span><span class="hljs-meta"># j</span><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">hexo</span> g<span class="hljs-comment"># 生成静态文件</span><br>hexo s<span class="hljs-comment"># 启动本地服务</span><br></code></pre></td></tr></table></figure><p>​        接下来浏览器访问 <a href="http://localhost:4000，内容为hexo初始化自带的hello">http://localhost:4000，内容为hexo初始化自带的hello</a> world文章</p><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220303010919115.png" alt="image-20220303010919115" style="zoom: 25%;"><ul><li><p><strong>部署到GitHub</strong></p><p>修改目录下的 _config.yml中的deploy字段，添加仓库地址以及设置分支</p><p><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220303224123266.png" alt="image-20220303224123266"></p></li></ul><p>​        hexo提供了hexo-deployer-git插件，使用户能方便的部署到github仓库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> hexo-deployer-git<br></code></pre></td></tr></table></figure><p>​        至此执行命令 <code>hexo d</code> 即可部署到github仓库</p><h2 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h2><p>有许多用户开源的主题可以使用，这里使用了 hexo-theme-yun，主题文档：<a href="https://yun.yunyoujun.cn/guide/">https://yun.yunyoujun.cn/guide/</a></p><ul><li><p><strong>下载主题</strong></p><p>根据hexo文档提供的指令下载</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i hexo-theme-yun<br></code></pre></td></tr></table></figure></li><li><p><strong>修改 _config.yml</strong></p><p>找到theme字段，改为<code>theme: yun</code></p></li><li><p><strong>安装主题所需插件</strong></p><p>除了hexo自带的stylus，该主题还需要pug</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">npm install hexo-<span class="hljs-keyword">render</span>-pug hexo-<span class="hljs-keyword">renderer</span>-stylus<br></code></pre></td></tr></table></figure></li><li><p><strong>自定义主题配置</strong></p><p>根据主题文档，可以再目录下新建文件 _config.yun.yml，主题会自动载入该文件下的配置。</p><p>譬如修改头像，在 _config.yun.yml文件中添加：</p><p>在source下新建文件夹images</p><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220303230254080.png" alt="image-20220303230254080" style="zoom: 67%;"></li></ul><p>​        更多自定义配置参考主题文档</p><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><ul><li><p><strong>新建文章</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;文章名&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>修改 _config.yml文件</strong></p><p>找到 post_asset_folder字段，将false改为true。</p><p>修改后，每当我们新建一个文章，hexo就会自动生成一个主题同名文件夹，用来存放文章内的图片。</p><p>执行命令  :</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type"></span>&quot;<span class="hljs-keyword">new</span><span class="hljs-type"></span>博客<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>利用Typora撰写</strong></p><p>对以下选择进行勾选，这样我们复制图片在Typora时会自动在hexo生成的文件夹中保存。</p><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220303233844272.png" alt="image-20220303233844272" style="zoom: 50%;"></li><li><p><strong>设置分类，标签</strong></p><p>执行命令（设置分类）</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> categories<br></code></pre></td></tr></table></figure><p>该命令会在source文件夹下新建一个categories文件夹，打开其中的index.md文件，添加type行</p><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220324180520426.png" alt="image-20220324180520426" style="zoom:67%;"><p>这样就可以在文章中添加分类了，格式如下：</p><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220324180723367.png" alt="image-20220324180723367" style="zoom:67%;"><p>执行命令（设置标签）</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> tags<br></code></pre></td></tr></table></figure><p>步骤如上，在tags文件夹index.md文件添加type:  “tags”, 之后就能添加标签了</p><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220324181018213.png" alt="image-20220324181018213" style="zoom:67%;"></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p><strong>绑定域名</strong></p><p>需要先设定域名解析到GitHub仓库ip</p><p>在source文件夹下新建CNAME文件，内容为需要绑定的域名</p></li></ul><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220303234439102.png" alt="image-20220303234439102" style="zoom: 80%;"><p>​        部署完成后就可以通过访问hah3.com查看博客了</p><ul><li><p><strong>浏览器图片不显示</strong></p><p>图片地址重定向错误，安装插件解决，执行命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/CodeFalling/</span>hexo-asset-image --save<br></code></pre></td></tr></table></figure></li><li><p><strong>启动本地服务显示正常，部署到github后出现排版混乱</strong></p><p>需强制刷新浏览器缓存，shift+f5刷新，才能显示修改后的新界面</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
