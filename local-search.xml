<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>8-30</title>
    <link href="/2022/08/30/8-30/"/>
    <url>/2022/08/30/8-30/</url>
    
    <content type="html"><![CDATA[<h1 id="8-30"><a href="#8-30" class="headerlink" title="8-30"></a>8-30</h1><h3 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h3><p><strong>压缩</strong></p><p>gzip命令、bzip2命令</p><p>制作压缩文件、揭开压缩文件</p><ul><li><code>gzip [-9] [文件名...]</code></li><li><code>bzip2 [-9] [文件名...]</code></li><li><code>gzip -d [.gz格式压缩文件]</code></li><li><code>bzip2 -d [.bz2格式压缩文件]</code></li></ul><p>gzip和bzip2命令使用的压缩算法不同，一般来说bzip2的压缩少率更好一些</p><p><strong>解压</strong></p><p><strong>gunzip</strong>命令，等价于gzip -d，<code>gunzip file.gz</code>或<code>gzip -d file.gz</code></p><p><strong>bunzip2</strong>命令，与gunzip用法一致</p><h4 id="归档命令tar命令"><a href="#归档命令tar命令" class="headerlink" title="归档命令tar命令"></a>归档命令tar命令</h4><p>制作归档文件、释放归档文件</p><p><code>tar [选项...] [归档文件名] [源文件或目录]</code></p><p><code>tar [选项...] [归档文件名] [-C 目标目录]</code></p><p>常用命令选项</p><ul><li>-c：创建.tar格式的包文件</li><li>-x：解开.tar格式的包文件</li><li>-v：输出出详细信息（进度条等）</li><li>-f：表示使用归档文件*</li><li>-p：打包时保留原始文件及目录权限</li><li>-t：列表查看包内的文件</li><li>-C：解包时指定释放的目标文件夹</li><li>-z：调用gzip程序进行压缩或解压</li><li>-j：调用bzip2程序进行压缩或解压</li></ul><p>创建归档：<code>tar zcf /root/test.tar.gz /etc/httpd /etc/shadow</code></p><p>解包归档：<code>tar zxf /root/test.tar.gz -C /tmp/</code></p><p>查看归档：<code>tar ztf /root/test.tar.gz</code></p><h4 id="解压命令总结"><a href="#解压命令总结" class="headerlink" title="解压命令总结"></a>解压命令总结</h4><ul><li>tar：tar -xvf</li><li>gz：gzip -d 或 gunzip</li><li>tar.gz：tar -zxf</li><li>bz2：bzip2 -d 或 bunzip2</li><li>tar.bz2：tar-xjf</li><li>rar：unrar -e</li><li>zip：unzip</li><li>…</li></ul><h3 id="vim文本编辑器"><a href="#vim文本编辑器" class="headerlink" title="vim文本编辑器"></a>vim文本编辑器</h3><p>创建或修改文件</p><ul><li>vi：类unix操作系统的默认文本编辑器</li><li>vim：是vi编辑器的增强版本</li></ul><p>操作</p><ul><li>插入内容光标编辑文件：i</li><li>退出编辑模式：q</li><li>删除键：backspace</li><li>操作键：冒号：</li><li>保存：w</li><li>退出：q</li><li>强制：！</li><li>左右上下：h、j、k、l</li><li>向上翻页：ctrl+f</li><li>向下翻页：ctrl+b</li><li>移动光标到最上方：H</li><li>移动光标到当前页中间：M</li><li>移动光标到最下方：K</li><li>移动光标到行首：0**</li><li>移动光标到行尾：$</li><li>删除本行：dd</li><li>往下删除n行：ndd</li><li>复制本行：yy</li><li>向下复制n行：nyy</li><li>撤销：u</li><li>重做上一步：ctrl+r</li></ul><p>内容查找</p><ul><li>向下查找字符串：&#x2F;字符串</li><li>向上查找字符串：?字符串</li></ul><h2 id="软件安装与用户权限"><a href="#软件安装与用户权限" class="headerlink" title="软件安装与用户权限"></a>软件安装与用户权限</h2><h3 id="应用程序与系统命令的关系"><a href="#应用程序与系统命令的关系" class="headerlink" title="应用程序与系统命令的关系"></a>应用程序与系统命令的关系</h3><p>文件位置</p><ol><li>系统命令：一般在&#x2F;bin（用户指令）和&#x2F;shin（root&#x2F;超级用户指令）目录中，或为shell内部指令</li><li>应用程序：通常在&#x2F;usr&#x2F;bin和&#x2F;usr&#x2F;sbin目录中</li></ol><p>主要用途</p><ol><li>系统命令：完成对系统的基本管理工作，例如ip配置工具</li><li>应用程序：完成相对独立的其他辅助任务，例如网页浏览器</li></ol><p>适用环境</p><ol><li>系统命令：一般只在字符操作界面中运行</li><li>应用程序：根据实际需要，有些程序可在图形界面中运行</li></ol><p>运行格式</p><ol><li>系统命令：一般包括命令字、命令选项和命令参数</li><li>应用程序：通常没有固定的执行格式</li></ol><h4 id="典型应用程序的目录结构"><a href="#典型应用程序的目录结构" class="headerlink" title="典型应用程序的目录结构"></a>典型应用程序的目录结构</h4><img src="/2022/08/30/8-30/image-20220830102234508.png" alt="image-20220830102234508" style="zoom:50%;"><h4 id="常见的软件包封装类型"><a href="#常见的软件包封装类型" class="headerlink" title="常见的软件包封装类型"></a>常见的软件包封装类型</h4><img src="/2022/08/30/8-30/image-20220830102907604.png" alt="image-20220830102907604" style="zoom:50%;"><h3 id="常见的软件包封装类型-1"><a href="#常见的软件包封装类型-1" class="headerlink" title="常见的软件包封装类型"></a><strong>常见的软件包封装类型</strong></h3><img src="/2022/08/30/8-30/image-20220830212919282.png" alt="image-20220830212919282" style="zoom:50%;"><h3 id="RPM包管理工具"><a href="#RPM包管理工具" class="headerlink" title="RPM包管理工具"></a>RPM包管理工具</h3><img src="/2022/08/30/8-30/image-20220830213355955.png" alt="image-20220830213355955" style="zoom:50%;"><p>无法被Ubuntu使用</p><ul><li>建立统一的数据库</li><li>详细记录软件包安装、卸载等变化信息</li><li>自动分析软件包依赖关系</li></ul><p>格式：<code>rpm -q[子选项] [软件名]</code></p><p><strong>查询文件或目录属于哪个RPM软件</strong></p><img src="/2022/08/30/8-30/image-20220830214341600.png" alt="image-20220830214341600" style="zoom:50%;"><p><strong>已安装RPM包常见指令</strong></p><ul><li><code>rpm -qa</code>：查询已安装的rpm包</li><li><code>rpm -ql [rpm包名]</code>：查看该rpm包的相关安装路径</li><li><code>rpm -qi [rpm包名]</code> ：查看该rpm包的详细信息</li><li><code>rpm -qd [rpm包名]</code>：查看该rpm包的文档安装位置</li><li><code>rpm -qR [rpm包名]</code>：查看该rpm包依赖的软件包和文件等</li></ul><p><strong>未安装RPM包常见指令</strong></p><p>-qpa、-qpl、-qpi、-qpd、-qpR</p><p>必须指定未安装的RPM包</p><p><strong>查询已安装的RPM软件信息</strong></p><p><code>rpm -qf [文件或目录名]</code></p><p><strong>查询未安装的RPM包文件</strong></p><p><code>rpm -qp[子选项] RPM包文件</code></p><p><strong>安装或升级RPM软件</strong></p><p><code>rpm [选项] [RPM包文件...]</code></p><p>常用选项</p><ul><li>-i：安装一个新的rmp软件包</li><li>-U：升级某个rpm软件，若原本未被安装，则会进行安装</li><li>-F：更新某个rpm软件，若原本未被安装，则放弃安装</li></ul><p><strong>卸载指定的RPM软件</strong></p><p><code>rpm -e [软件名]</code></p><p><strong>辅助选项</strong></p><ul><li>-H：以 “#” 号显示安装的进度建立统一的数据库文件</li><li>-v：显示安装过程中的详细信息</li></ul><p><strong>安装或卸载有依赖关系的软件</strong></p><p>结合 –nodeps 选项忽略依赖关系，但可能导致软件异常</p><p><strong>RPM数据库</strong></p><p>重建RPM数据库（当RPM数据库error时使用）</p><p>打开RPM数据库所在目录(&#x2F;var&#x2F;lib&#x2F;rpm)，删除数据库文件(rm -rf __db.*)，再进行重建</p><img src="/2022/08/30/8-30/image-20220830220548677.png" alt="image-20220830220548677" style="zoom:50%;"><p>导入验证公钥*</p><img src="/2022/08/30/8-30/image-20220830221153982.png" alt="image-20220830221153982" style="zoom:50%;"><h3 id="源代码编译概述"><a href="#源代码编译概述" class="headerlink" title="源代码编译概述"></a>源代码编译概述</h3><p><strong>使用源代码安装软件的优点</strong></p><ul><li>获得最新的软件版本，及时修复bug</li><li>根据用户需要，灵活定制软件功能</li></ul><p><strong>应用场合举例</strong></p><ul><li>安装较新版本的应用程序时</li><li>当前安装的出现无法满足需求时</li><li>需要为应用程序添加新的功能时</li></ul><p><strong>编译安装源代码包</strong></p><img src="/2022/08/30/8-30/image-20220830112513446.png" alt="image-20220830112513446" style="zoom:50%;"><p><strong>编译安装过程</strong></p><img src="/2022/08/30/8-30/image-20220830112701068.png" alt="image-20220830112701068" style="zoom:50%;"><p><strong>编译安装源码</strong></p><ul><li>解压 tar zxf</li><li>配置 .&#x2F;configure –prefix&#x3D;安装apache路径</li><li>编译 make</li><li>安装 make install</li><li>开启web服务：apachectl start</li><li>访问本机ip，测试web服务是否开启</li></ul><h3 id="章节提问"><a href="#章节提问" class="headerlink" title="章节提问"></a>章节提问</h3><p>1、rpm、deb、源代码程序、绿色软件</p><p>2、<code>rpm -qa | wc -l</code></p><p>3、<code>rpm -qld samba</code></p><p>4、查看未安装ethtool的信息</p><p>5、<code>mount /dev/cdrom/mnt</code>、<code>/mnt/Packages/vsftpd-3.0.2-22.el7.x86_64.rpm</code>、<code>/mnt/Packages/vsftpd-3.0.2-22.el7.x86_64.rpm</code></p><p>6、使用yum、先安装依赖关系包、忽略依赖关系安装</p><p>7、<code>rpm --rebuilddb</code></p><p>8、解压包、配置程序、编译、安装</p><p>9、指定安装目录</p><p>10、make命令执行成功后继续执行make install</p><h3 id="账号和权限管理"><a href="#账号和权限管理" class="headerlink" title="账号和权限管理"></a>账号和权限管理</h3><h4 id="管理用户和组账号"><a href="#管理用户和组账号" class="headerlink" title="管理用户和组账号"></a>管理用户和组账号</h4><p>用户账号</p><ul><li>超级用户</li><li>普通用户</li><li>程序用户</li></ul><p>组账号</p><ul><li>基本组（私有组）</li><li>附加组（公有组）</li></ul><p>UID和GID</p><ul><li>UID（userID用户标识号）</li><li>GID（groupID组标识号）</li></ul><img src="/2022/08/30/8-30/image-20220830143031121.png" alt="image-20220830143031121" style="zoom:50%;"><img src="/2022/08/30/8-30/image-20220830145310605.png" alt="image-20220830145310605" style="zoom:50%;"><p>添加用户账号</p><img src="/2022/08/30/8-30/image-20220830145723895.png" alt="image-20220830145723895" style="zoom:50%;"><img src="/2022/08/30/8-30/image-20220830145844960.png" alt="image-20220830145844960" style="zoom:50%;"><p><strong>用户账号的初始配置文件</strong></p><img src="/2022/08/30/8-30/image-20220830150758367.png" alt="image-20220830150758367" style="zoom:50%;"><p><strong>设置账号密码</strong></p><img src="/2022/08/30/8-30/image-20220830151021146.png" alt="image-20220830151021146" style="zoom:50%;"><p><strong>修改账号属性</strong></p><img src="/2022/08/30/8-30/image-20220830151352850.png" alt="image-20220830151352850" style="zoom:50%;"><p><strong>删除用户账号</strong></p><img src="/2022/08/30/8-30/image-20220830151955931.png" alt="image-20220830151955931" style="zoom:50%;"><h3 id="小节提问"><a href="#小节提问" class="headerlink" title="小节提问"></a>小节提问</h3><ol><li>​    &#x2F;etc&#x2F;passwd基本信息和&#x2F;etc&#x2F;shardow用户密码、有效期等</li><li></li></ol><p><strong>组账号文件</strong></p><img src="/2022/08/30/8-30/image-20220830153355106.png" alt="image-20220830153355106" style="zoom:50%;"><p><strong>添加组账号</strong>groupadd</p><img src="/2022/08/30/8-30/image-20220830153548489.png" alt="image-20220830153548489" style="zoom:50%;"><p><strong>用户加入组</strong></p><img src="/2022/08/30/8-30/image-20220830153650648.png" alt="image-20220830153650648" style="zoom:50%;"><p><strong>删除组账号</strong></p><img src="/2022/08/30/8-30/image-20220830153736900.png" alt="image-20220830153736900" style="zoom: 50%;"><p><strong>小节提问</strong></p><ol><li><code>groupadd [-g GID] 组账号名</code>、<code>groupdel 组账号名</code>。作用分别是添加组账号和删除组账号</li><li>设置组账号密码、添加、删除组成员，-a向组内添加一个用户，-M定义组成员列表</li></ol><p><strong>账号的查询命令</strong></p><img src="/2022/08/30/8-30/image-20220830154431388.png" alt="image-20220830154431388" style="zoom:50%;"><p><strong>文件&#x2F;目录的权限和归属</strong></p><img src="/2022/08/30/8-30/image-20220830154731048.png" alt="image-20220830154731048" style="zoom:50%;"><img src="/2022/08/30/8-30/image-20220830154847088.png" alt="image-20220830154847088" style="zoom:50%;"><p><strong>chmod</strong></p><img src="/2022/08/30/8-30/image-20220830155331510.png" alt="image-20220830155331510" style="zoom:50%;"><p>变更属主、属组</p><img src="/2022/08/30/8-30/image-20220830155538346.png" alt="image-20220830155538346" style="zoom:50%;"><h4 id="小节提问-1"><a href="#小节提问-1" class="headerlink" title="小节提问"></a>小节提问</h4><p>1、<code>chmod [ugoa] [+-=] [rwx] 文件或目录</code>、<code>chown [属主/属组]/[属主:属组] [文件或目录]</code></p><p>2、4：可读、2：可写、1：可执行</p><p>3、所有者可读可写可执行，所有组可读可写，其他用户可读</p><p><strong>文件底层属性</strong></p><p>系统层面的属性*</p><p><img src="/2022/08/30/8-30/image-20220830160711178.png" alt="image-20220830160711178"></p><p>更改底层属性</p><img src="/2022/08/30/8-30/image-20220830160822036.png" alt="image-20220830160822036" style="zoom:50%;"><p><strong>附加权限SET位</strong></p><img src="/2022/08/30/8-30/image-20220830161113811.png" alt="image-20220830161113811" style="zoom:50%;"><p>例如&#x2F;etc&#x2F;shadow文件无任何权限，但当用户使用<code>passwd</code>修改密码时，shadow的内容会改变。因为<code>passwd</code>命令***</p><p><strong>粘滞位</strong></p><img src="/2022/08/30/8-30/image-20220830161527354.png" alt="image-20220830161527354" style="zoom:50%;"><img src="/2022/08/30/8-30/image-20220830162136742.png" alt="image-20220830162136742" style="zoom:50%;">]]></content>
    
    
    
    <tags>
      
      <tag>linux解压缩文件</tag>
      
      <tag>linux源代码编译</tag>
      
      <tag>linux vim操作</tag>
      
      <tag>linux软件安装</tag>
      
      <tag>linux用户权限</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.29</title>
    <link href="/2022/08/29/8-29/"/>
    <url>/2022/08/29/8-29/</url>
    
    <content type="html"><![CDATA[<h1 id="8-29"><a href="#8-29" class="headerlink" title="8.29"></a>8.29</h1><h3 id="建立分区遵循的顺序"><a href="#建立分区遵循的顺序" class="headerlink" title="建立分区遵循的顺序"></a>建立分区遵循的顺序</h3><p>建立主分区（至少一个）–&gt; 建立扩展分区（至多一个）–&gt; 建立逻辑分区（若干个）–&gt; 激活主分区 –&gt; 格式化所有分区</p><p>硬盘容量 &#x3D; 主分区容量 + 扩展分区容量</p><p>扩展分区容量 &#x3D; 若干个逻辑分区的容量总数</p><p>主分区 + 若干个逻辑分区 &#x3D; 驱动器&#x2F;卷（逻辑磁盘）</p><h3 id="分区表现形式"><a href="#分区表现形式" class="headerlink" title="分区表现形式"></a>分区表现形式</h3><p>hd表示IDE设备</p><p>sd表示SCSI设备</p><p>紧跟硬盘顺序号（字母表示）</p><p>紧跟分区顺序号（数字表示）</p><p>hda4（第一块IDE硬盘的第四个分区）</p><p>sdb6（第二块SCSI硬盘的第2个逻辑分区，主分区只有4个，往后即逻辑分区）</p><p>CentOS8默认使用的文件系统类型：<strong>XSF</strong>–日志文件系统（CentOS7+，往前版本使用ext4），可满足使用最大16tb的文件，效率高</p><p>重点目录</p><ul><li>bin：文件系统启动时启动</li><li>boot：启动时加载核心文件</li><li>dev：存放设备的目录，提供接口</li><li><strong>etc：</strong>存放关于系统、管理的用户文件</li><li>home：用户目录</li><li>lib：存放共享链接库，动态链接库**</li><li>proc：存放系统进程 、核心程序的信息</li><li>root：root用户的主目录</li><li>sbin：存放系统启动的一些命令（root常用）</li><li>tmp：用户存放的临时文件</li><li>usr：大多数安装的服务在此目录下</li><li><strong>var：</strong>存放系统日志、web日志、数据库日志、web源代码、邮箱等</li></ul><p>绝对路径：从根目录展开</p><p>相对路径：从当前目录展开</p><p><strong>挂载</strong></p><ul><li>&#x2F;</li><li>boot</li><li>swap：交换分区（虚拟内存）</li><li>XFS：日志文件系统</li></ul><h3 id="inode节点与块"><a href="#inode节点与块" class="headerlink" title="inode节点与块"></a>inode节点与块</h3><p>硬盘存储最小单位：扇区sector（512字节&#x3D;0.5kb）</p><p>常见8个扇区为一个块（block）：4kb</p><p>一个文件分为两个区域：</p><p>1、元数据（创建者、创建日期、大小、操作权限、存放文件数据块的位置、链接数等，称为索引节点）</p><ul><li><p>inode区域：存储元数据的区域</p></li><li><p>inode bitmap：inode的使用情况，比如空闲inode</p></li><li><p>block bitmap：块的使用情况，比如空闲inode与空闲块等信息</p></li></ul><p>2、数据块（文件内容、目录信息）</p><img src="/2022/08/29/8-29/image-20220829100106710.png" alt="image-20220829100106710" style="zoom: 50%;"><img src="/2022/08/29/8-29/image-20220829101651357.png" alt="image-20220829101651357" style="zoom: 50%;"><h3 id="简化linux系统服务"><a href="#简化linux系统服务" class="headerlink" title="简化linux系统服务"></a>简化linux系统服务</h3><p><code>systemctl stop firewall</code>：关闭防火墙</p><p><code>iptables -F</code>：清除防火墙规则</p><p><code>setenforce 0</code>：关闭selinux防火墙</p><h3 id="Linux系统引导过程"><a href="#Linux系统引导过程" class="headerlink" title="Linux系统引导过程"></a>Linux系统引导过程</h3><ul><li>开机自检BIOS：开机检测设备，将设别启动顺序交给系统</li><li>MBR引导：（硬盘中的第一个扇区）主引导记录，引导设备启动等</li><li>GRUB菜单：统一启动加载器，根据用户选择加载不同内核等</li><li>加载内核（kernel）：根据GRUB菜单加载响应内核。</li><li>init进程初始化：由linux内核加载运行，在sbin文件夹下的可执行文件。</li></ul><p>可执行程序</p><ul><li>.exe：windows</li><li>.elf：linux</li></ul><h3 id="init与systemd"><a href="#init与systemd" class="headerlink" title="init与systemd"></a>init与systemd</h3><p>init进程是系统中第一个进程，PID号永远是1</p><h5 id="systemd进程"><a href="#systemd进程" class="headerlink" title="systemd进程"></a>systemd进程</h5><p>代替init进程，成为主流</p><p>具有向下兼容，更快的启动速度，集中化命令管理，更合理的命令结构等优势</p><img src="/2022/08/29/8-29/image-20220829110254284.png" alt="image-20220829110254284" style="zoom: 50%;"><p>可通过  <code>init 1-6</code> 切换运行级别</p><img src="/2022/08/29/8-29/image-20220829110330050.png" alt="image-20220829110330050" style="zoom: 50%;"><h3 id="小节提问"><a href="#小节提问" class="headerlink" title="小节提问"></a>小节提问</h3><p>1、第2块SCSI硬盘的第3个逻辑分区：</p><p><strong>sdb7</strong>（因为主分区只能有4个，所以逻辑分区从第5个开始表示）</p><p>2、CentOS8默认使用的文件系统类型：XSF</p><p>3、inode节点用光了会怎样：无法再储存文件</p><p>4、systemd进程的PID是多少：1</p><h5 id="systemctl系统服务控制"><a href="#systemctl系统服务控制" class="headerlink" title="systemctl系统服务控制"></a>systemctl系统服务控制</h5><ul><li>start：启动</li><li>stop：停止</li><li>restart：重新启动</li><li>reload：重新加载</li><li>status：查看服务状态</li><li>……</li></ul><p>常用</p><ul><li><code>systemctl stop firewalld</code>  #关闭防火墙</li><li><code>systemctl reboot</code> #重启</li><li><code>systemctl status 服务名称</code> #查看服务的系统状态 </li><li><code>systemctl restart 服务名称</code> # 重启服务</li><li><code>systemctl enabled 服务名称</code> #设置为开机自启动</li><li><code>systemctl disabled 服务名称</code> # 设置为开机禁止启动</li><li><code>systemctl list-dependencies 服务名称</code> #查看该服务的依赖项</li></ul><h4 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h4><img src="/2022/08/29/8-29/image-20220829115543065.png" alt="image-20220829115543065" style="zoom: 50%;"><h4 id="系统服务管理工具"><a href="#系统服务管理工具" class="headerlink" title="系统服务管理工具"></a>系统服务管理工具</h4><p>ntsysv默认未下载，提供图形界面，但不推荐</p><img src="/2022/08/29/8-29/image-20220829115742181.png" alt="image-20220829115742181" style="zoom:50%;"><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><ul><li><strong>&#x2F;bin&#x2F;sh</strong></li><li><strong>&#x2F;bin&#x2F;bash</strong></li><li>&#x2F;bin&#x2F;zsh</li><li>&#x2F;bin&#x2F;tcsh</li><li>&#x2F;bin&#x2F;csh</li></ul><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><ul><li>设备系统</li><li>文件系统</li><li>进程系统</li><li>内存系统</li><li>网络系统</li></ul><h3 id="内外部命令分类"><a href="#内外部命令分类" class="headerlink" title="内外部命令分类"></a>内外部命令分类</h3><p>type查看某命令是内部还是内部命令</p><img src="/2022/08/29/8-29/image-20220829140829954.png" alt="image-20220829140829954" style="zoom:50%;"><h3 id="常见指令连接、快捷键"><a href="#常见指令连接、快捷键" class="headerlink" title="常见指令连接、快捷键"></a>常见指令连接、快捷键</h3><p>ctrl+i：清除全屏（相当于<code>clear</code>）</p><p>ctrl+k：删除光标以后的字符</p><p>ctrl+u：删除光标以后的字符</p><p>\：换行</p><p>esc+b：将光标移至行首</p><p>esc+f：将光标移至行尾</p><h3 id="获取命令帮助"><a href="#获取命令帮助" class="headerlink" title="获取命令帮助"></a>获取命令帮助</h3><ul><li>man：使用手册，例 <code>man ls</code>，参数 -f 可展示帮助文档目录</li><li>help</li><li>–help</li></ul><h3 id="重定向与管道"><a href="#重定向与管道" class="headerlink" title="重定向与管道"></a>重定向与管道</h3><img src="/2022/08/29/8-29/image-20220829150219836.png" alt="image-20220829150219836" style="zoom:50%;"><p><strong>重定向</strong></p><p>例 <code>echo &#39;hello&#39; &gt; 1.txt</code>，文件不存在则创建并写入</p><ul><li>&gt;：覆盖写入内容</li><li>&gt;&gt; ：追加内容</li></ul><p><strong>管道符 <code>|</code></strong></p><p>将 <code>|</code> 前面命令的输出的结果作为 <code>|</code> 后面命令的参数输入</p><p><code>ls | wc -l &gt;&gt; 1.txt</code></p><h3 id="小节提问-1"><a href="#小节提问-1" class="headerlink" title="小节提问"></a>小节提问</h3><ol><li>Linux操作系统通用的命令行格式是什么？</li><li>列表对比Linux操作系统下获取命令帮助的方法</li><li>操作命令选项的时候“-”和“–”的区别是什么？</li><li>help和–help分别代表什么意思？</li><li>重定向符的作用是什么？</li></ol><hr><ol><li>命令 参数</li><li>man可以展示帮助文档列表，help、–help大同小异</li><li>-为短选项，–为长选项</li><li>–help是作为命令参数使用，help查看内部命令，–help查看外部命令</li><li>重定向符作用是将标准输出结果保存到文件中</li></ol><h3 id="目录和文件基本操作"><a href="#目录和文件基本操作" class="headerlink" title="目录和文件基本操作"></a>目录和文件基本操作</h3><h4 id="查看及切换目录"><a href="#查看及切换目录" class="headerlink" title="查看及切换目录"></a>查看及切换目录</h4><ul><li><p>**<code>pwd</code>**：显示用户当前所在的工作目录</p></li><li><p>**<code>cd</code>**：将用户的工作目录更改到其他位置</p><img src="/2022/08/29/8-29/image-20220829151249400.png" alt="image-20220829151249400" style="zoom:50%;"><p>相对路径的表现形式</p><img src="/2022/08/29/8-29/image-20220829151427771.png" alt="image-20220829151427771" style="zoom:50%;"></li><li><p>**<code>ls</code>**：显示目录内容，包括子目录和文件相关属性信息，可结合通配符：</p><ul><li>?：匹配文件名中的一个未知字符</li><li>*：匹配文件名中的任意多个字符</li></ul></li><li><p>**<code>alias</code>**：通过别名机制简化常用的、比较长的命令，<code>alias 命令=&#39;别名&#39;</code>，<code>alias -1</code>可查看当前所用使用别名的命令</p></li><li><p>**<code>du</code>**：统计指定目录，所占用磁盘空间的大小 <code>du [选项] [文件或目录...]</code>，常用参数：</p><ul><li>-a：统计磁盘空间占用时包括所有的文件（不仅仅统计目录）</li><li>-h：显示出目录或文件的大小，默认单位为字节（KB）</li><li>-s：只统计每个参数所占用空间总的大小，而不是统计每个子目录、文件的大小</li></ul></li></ul><h4 id="创建目录和文件"><a href="#创建目录和文件" class="headerlink" title="创建目录和文件"></a><strong>创建目录和文件</strong></h4><ul><li><p>**<code>mkdir</code>**：创建文件工作目录，-p参数一次性可创建多层目录</p></li><li><p>**<code>touch</code>**：创建空文件</p></li><li><p>**<code>ln</code>**：软硬链接（类似与Windows的快捷方式）</p><img src="/2022/08/29/8-29/image-20220829164739545.png" alt="image-20220829164739545" style="zoom:50%;"><p><strong>硬链接</strong>：<code>ln</code>与原始文件一模一样，删除原始文件该文件依旧能使用</p><p><strong>软链接</strong>：<code>ln -s</code>链接源文件，删除源文件则软连接失效</p><p>修改文件时软硬链接的文件同时也会修改，修改软硬链接的文件源文件也会修改</p></li></ul><h4 id="复制、删除、移动目录和文件"><a href="#复制、删除、移动目录和文件" class="headerlink" title="复制、删除、移动目录和文件"></a>复制、删除、移动目录和文件</h4><ul><li><p>**<code>cp</code>**：复制文件，<code>cp [选项].. [源文件或目录].. [目标文件或目录]..</code>，常用参数：</p><ul><li>-f：覆盖目标同名文件或目录时不进行提醒，直接强制复制</li><li>-i：覆盖目标同名文件或目录时提醒用户确认</li><li>-p：复制时保持原文件的权限、属主及时间标记等属性不变</li><li>-r：复制目录时必须使用此选项，表示递归复制所有文件及子目录</li></ul><p>注意复制多个文件或目录时，目标位置必须是目录，且目标目录必须以存在</p></li><li><p>**<code>rm</code>**：删除指定文件或目录，<code>rm [选项] [要删除的文件或目录]...</code>，常用参数：-f、-i、-r（尽量避免使用）</p><p>-rl可删除目录</p></li><li><p>**<code>mv</code>**：移动置顶文件位置，若目标文职与原位置相同，则相当于重命名操作。<code>mv [选项].. [源文件或目录].. [目标文件或目录]..</code></p></li></ul><h4 id="查找目录和文件"><a href="#查找目录和文件" class="headerlink" title="查找目录和文件"></a>查找目录和文件</h4><ul><li><p>**<code>which</code>**：查看命令或可执行文件所在目录</p></li><li><p>**<code>find</code>**：采用递归方式，根据目标的名称、类型、大小等不同属性进行精细查找</p><p><code>find [查找范围] [查找条件表达式]</code></p><img src="/2022/08/29/8-29/image-20220829160349744.png" alt="image-20220829160349744" style="zoom:50%;"><img src="/2022/08/29/8-29/image-20220829160654790.png" alt="image-20220829160654790" style="zoom:50%;"></li></ul><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><h4 id="查看和检索文件"><a href="#查看和检索文件" class="headerlink" title="查看和检索文件"></a>查看和检索文件</h4><ul><li><p>**<code>cat</code>**：显示文件内容，<code>cat [选项] [文件名]..</code>，常用选项：</p><ul><li>-n：赋予显示内容行号</li><li>-b：赋予显示内容行号，不包括空行</li></ul></li><li><p>**<code>more</code>**：全屏形式分页显示文件内容，<code>more [选项] [文件名]..</code>，交互方式：</p><ul><li>按Enter建向下逐行滚动</li><li>按空格键向下翻一屏</li><li>按q退出</li></ul></li><li><p>**<code>less</code>**：与more命令相同，但扩展功能多，<code>less [选项] [文件名]..</code>，交互方式：</p><ul><li>Page Up向上翻页，Page Down向下翻页</li><li>按”&#x2F;“键查找内容，”n”下一个内容，”N”上一个内容</li><li>其他基本与more相似</li></ul></li><li><p>**<code>head</code>**：查看文件开头的一部分内容（默认为10行）<code>head -n [文件名]..</code>。-n选项：n为数字，代表显示几行</p></li><li><p><strong><code>tail</code></strong>:查看文件结尾的少部分内容（默认为10行）<code>tail -f [文件名]</code>。-n选项与head相同，-f选项表示动态监视文件末行内容</p></li><li><p>**<code>wc</code>**：统计文件中的单词数量等信息，<code>wc [选项].. [目标文件]..</code>，常用选项：</p><ul><li>-l：统计行数</li><li>-w:统计单词个数</li><li>-c：统计字节数</li></ul><p>例<code>cat /etc/root/ | wc -l</code></p></li><li><p>**<code>grep</code>**：在文件中查找并显示包含指定字符串的行，<code>grep [选项].. [查找条件] [目标文件]</code>，常用选项：</p><ul><li>-i：查找忽略大小写</li><li>-v：反转查找，输出与查找条件不相符的行</li></ul><p>查找条件设置：</p><ul><li>要查找的字符串以双引号括起来</li><li>“^…”表示以…开头，”…$”表示以…结尾</li><li>“^$”表示空行</li></ul><p>例 <code>grep ^Server /etc/httpd/conf/httpd.conf</code>、<code>systemctl list-unit-files | grep httpd</code></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>珂兰寺</tag>
      
      <tag>linux基本安装使用</tag>
      
      <tag>linux基础命令</tag>
      
      <tag>重定向</tag>
      
      <tag>管道</tag>
      
      <tag>inode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.26</title>
    <link href="/2022/08/29/8-26/"/>
    <url>/2022/08/29/8-26/</url>
    
    <content type="html"><![CDATA[<h1 id="8-26"><a href="#8-26" class="headerlink" title="8.26"></a>8.26</h1><h3 id="软件环境的安装"><a href="#软件环境的安装" class="headerlink" title="软件环境的安装"></a>软件环境的安装</h3><p>vmware版本需大于16，不然可能会导致centos8安装无法</p><p>安装不同版本的python会造成系统变量同名冲突，需进行手动修改名称，以区分不同版本的python执行文件</p><p>本机的python默认执行python3.10,输入python2执行python2.7</p><h4 id="需要下载"><a href="#需要下载" class="headerlink" title="需要下载"></a>需要下载</h4><ul><li>JAVA JDK 1.8</li><li>Python2（不再维护）</li><li>Python3</li><li>burpsuite</li></ul><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>火狐（插件安装不需要翻墙）</p><p>​    火狐取消自动更新</p><p>谷歌</p><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>桥接模式：与本机ip在一个网段下</p><p>net模式：从ip的c段改变</p><h4 id="kali"><a href="#kali" class="headerlink" title="kali"></a>kali</h4><p>命令行输入<code>sudo passwd root</code>初始化root密码</p><h4 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h4><p>LVM：当前linux下的分盘特性</p><p>挂载点：当前linux系统启动时会先将几个重要的文件系统启动即挂载点</p><h4 id="更改源"><a href="#更改源" class="headerlink" title="更改源"></a>更改源</h4><p>​    国内下载国外资源较慢，更换国内源下载资源较快</p><h4 id="备份文件"><a href="#备份文件" class="headerlink" title="备份文件"></a>备份文件</h4><p>file file.bak</p><h3 id="常用安全设备"><a href="#常用安全设备" class="headerlink" title="常用安全设备"></a>常用安全设备</h3><h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><p>隔断网络，拦截筛选网络，有延迟等影响</p><p>防护漏洞，无法防御破坏</p><h4 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h4><p>WEB层面的防火墙，防止黑客攻击，匹配恶意攻击进行隔断（常见漏洞：sql注入、xss、文件上传等等）</p><h4 id="IDS入侵检测系统"><a href="#IDS入侵检测系统" class="headerlink" title="IDS入侵检测系统"></a>IDS入侵检测系统</h4><p>对网络及系统运行情况进行随时监控，祭祀发现攻击企图，提醒管理进行防护</p><p>防火墙是一个门禁的识别系统，IDS就是进入门禁之后的监控系统</p><h4 id="IPS入侵防御系统"><a href="#IPS入侵防御系统" class="headerlink" title="IPS入侵防御系统"></a>IPS入侵防御系统</h4><p>防护和预防网络安全设备。功能是对防护墙、防病毒软件的补充</p><p>可以监控、并即使保护设备或服务器的安全设备</p><p>与IDS的区别，IPS可以在入口进行检测</p><h4 id="态势感知"><a href="#态势感知" class="headerlink" title="态势感知"></a>态势感知</h4><p>相当于集成以上的设备功能，显示攻击及攻击结果，提供漏洞修复建议等</p><h4 id="漏洞扫描器"><a href="#漏洞扫描器" class="headerlink" title="漏洞扫描器"></a>漏洞扫描器</h4><ul><li>web漏洞扫描器</li><li>系统漏洞扫描器</li><li>端口扫描器</li><li>数据库扫描器</li><li>网络扫描器</li></ul><h4 id="DDOS防护"><a href="#DDOS防护" class="headerlink" title="DDOS防护"></a>DDOS防护</h4><p>分布式拒绝服务攻击：消耗服务端的带宽，大量消耗服务端的资源。</p><h5 id="防护手段"><a href="#防护手段" class="headerlink" title="防护手段"></a>防护手段</h5><ul><li>入侵检测</li><li>流量过滤</li><li>流量清洗、封禁ip、扩大带宽</li></ul><p>ddos：大量的网络请求导致服务器崩溃</p><h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><p>内容分发网络。</p><p>部署在各区域的服务器，降低总服务器的工作量。</p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>把各个节点及接口连接在一起，通过互联网技术实现计算机和设备间的互相访问。</p><h4 id="计算机网络中的重要组件"><a href="#计算机网络中的重要组件" class="headerlink" title="计算机网络中的重要组件"></a>计算机网络中的重要组件</h4><ul><li>节点：有ip的计算机、设备</li><li>服务器：要发送请求的对方</li><li>客户端：进行发送的节点</li><li>网卡：外插或内插主机上的设备，可支持网络连接</li><li>网络接口：软件设计出来的。一张网卡可以有一个或以上的网络接口</li><li>网络拓扑：各个节点在网络层面的一种连接方式</li></ul><h4 id="局域网、广域网、无线局域网"><a href="#局域网、广域网、无线局域网" class="headerlink" title="局域网、广域网、无线局域网"></a>局域网、广域网、无线局域网</h4><h5 id="Lan局域网"><a href="#Lan局域网" class="headerlink" title="Lan局域网"></a>Lan局域网</h5><p>实现内部的资源访问共享</p><p>封闭的，可以由两台计算机组成，也可由上千台</p><h5 id="Wan广域网"><a href="#Wan广域网" class="headerlink" title="Wan广域网"></a>Wan广域网</h5><p>开放的，可以互相跨国访问的网络，其中也可以含有局域网和小型广域网</p><h5 id="Wlan无线局域网"><a href="#Wlan无线局域网" class="headerlink" title="Wlan无线局域网"></a>Wlan无线局域网</h5><p>无需网线连接的网络</p><h4 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h4><h5 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h5><p>通过交换机可实现多人访问同一个网络接口</p><h5 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h5><p>连接多个逻辑分开得到网络，连接互联网lan和wan的设备和计算机等</p><h5 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h5><p>增强信号</p><h5 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h5><p>增强信号，集中多个节点</p><h5 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h5><p>每台计算机的标识</p><h5 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h5><img src="/2022/08/29/8-26/image-20220826141214465.png" alt="image-20220826141214465" style="zoom:67%;"><ul><li>总线型：简单、便宜，运维困难</li><li>星型：适合局域网，运维方便</li><li>树形：只能上下层进行数据交互，同层无法交互，便于管理、效率较高，但利用率较差、上层节点负荷较大</li><li>环行：适合简单的设备、简单、速度快，一个节点出现问题可哪导致其余节点出错、可靠性低、维护困难</li><li>网型：利于数据交互，花费高</li><li>混合型：集合上述结构的有点，缺点是难维护</li></ul><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><p>描述网络速度。</p><h4 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h4><p>网络中传递及管理信息的规范准则。</p><ul><li>http协议：两个节点中传输文件、音频、图片等数据的规范</li><li>ip</li><li>tcp</li><li>udp</li><li>dns</li><li>usb</li></ul><p>http协议最常见，tcp&#x2F;ip协议最重要</p><h5 id="tcp-x2F-ip（网络体系结构）"><a href="#tcp-x2F-ip（网络体系结构）" class="headerlink" title="tcp&#x2F;ip（网络体系结构）"></a>tcp&#x2F;ip（网络体系结构）</h5><p>主要用于lan wan</p><h4 id="OSI参考模型（开放系统互连参考模型）"><a href="#OSI参考模型（开放系统互连参考模型）" class="headerlink" title="OSI参考模型（开放系统互连参考模型）*"></a>OSI参考模型（开放系统互连参考模型）*</h4><img src="/2022/08/29/8-26/image-20220826144913765.png" alt="image-20220826144913765" style="zoom:67%;"><ul><li><strong>应用层</strong>：软件</li><li><strong>表示层</strong>：通过计算机本身的编码形式将数据显示出来，例如mp3（声音编码）、jpeg（图片编码）、ascii（文字编码）</li><li><strong>会话层</strong>：app、一ing用、节点间能否对接产生会话</li></ul><p>以上都是应用开发相关，从传输层开始侧重于网络通信</p><ul><li><strong>传输层</strong>：两个重要的协议 <strong>tcp&#x2F;udp</strong>，tcp慢但质量高、udp快但质量低。本身会将当前传输通信的数据包加上端口号</li><li><strong>网络层</strong>（路由器在此层面工作）：传输层被加上协议和端口号之后，交给网络层，由网络层为当前这个数据包加上ip地址，才能进行发送。</li><li><strong>数据链路层</strong>（交换机在此层面工作）：将数据包交付给目标接收人。交换机通过mac地址进行识别各个终端。将数据包加上mac地址后通过交换机进行交换转发。</li><li><strong>物理层</strong>：根据物理层信号表示数据。</li></ul><h4 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h4><p>将OSI模型简化为四层</p><p>应用层、传输层、网络层、数据链路层</p><h4 id="TCP三次握手建立连接"><a href="#TCP三次握手建立连接" class="headerlink" title="TCP三次握手建立连接"></a>TCP三次握手建立连接</h4><p>为确保双方连接成功进行的交互。</p><img src="/2022/08/29/8-26/image-20220826154223216.png" alt="image-20220826154223216" style="zoom:67%;"><p>第一次：客户端向服务端发包，服务端收到数据包，确认客户端的发送能力和自身接收能力，并向客户端发包</p><p>第二次：客户端收到服务端的数据包，客户端确认服务端的接收能力和自身的发送能力，并再向服务端发包</p><p>第三次：服务端收到数据包，确认客户端的接收能力，建立连接成功</p><h4 id="数据的封装与解封"><a href="#数据的封装与解封" class="headerlink" title="数据的封装与解封"></a>数据的封装与解封</h4><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>应用层：原始数据转换为二进制数据</p><p>传输层：将数据加上tcp、udp协议标识，并且打sahng端口号</p><p>网络层：再将数据加上ip地址，打包packet数据包</p><p>数据链路层：打上mac地址，打包为frame数据帧；在物理层面（网线、光纤将这个数据帧的二进制数据封装为电频信号或者光信号）</p><h5 id="解封"><a href="#解封" class="headerlink" title="解封"></a>解封</h5><ul><li>数据链路层：物理层将数据变成二进制，然后发送给数据链路层；根据mac地址进行查看，分析网络层是哪个协议后将数据发送给网络层</li><li>网络层：查看ip地址，检验传输层是什么协议后将数据发送给传输层</li><li>传输层：检验端口号，将数据对应直接给应用层</li><li>应用层：成功将二进制数据以各种编码形式显示出来</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>珂兰寺</tag>
      
      <tag>环境配置</tag>
      
      <tag>网络基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2022/08/09/Docker/"/>
    <url>/2022/08/09/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="一、解决的问题"><a href="#一、解决的问题" class="headerlink" title="一、解决的问题"></a>一、解决的问题</h2><p>由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。</p><p>Docker 主要解决环境配置问题，它是一种虚拟化技术，<strong>对进程进行隔离</strong>，<strong>被隔离的进程独立于宿主操作系统和其它隔离的进程</strong>。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其它机器上。</p><h2 id="二、与虚拟机的比较"><a href="#二、与虚拟机的比较" class="headerlink" title="二、与虚拟机的比较"></a>二、与虚拟机的比较</h2><p>虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现。</p><h3 id="启动速度"><a href="#启动速度" class="headerlink" title="启动速度"></a>启动速度</h3><p>启动虚拟机需要先启动虚拟机的<strong>操作系统</strong>，再启动应用，这个过程非常慢；</p><p>而启动 Docker 相当于启动宿主操作系统上的一个<strong>进程</strong>。</p><h3 id="占用资源"><a href="#占用资源" class="headerlink" title="占用资源"></a>占用资源</h3><p>虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU 资源，一台机器只能开启几十个的虚拟机。</p><p>而 Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker。</p><h2 id="三、优势"><a href="#三、优势" class="headerlink" title="三、优势"></a>三、优势</h2><p>除了启动速度快以及占用资源少之外，Docker 具有以下优势：</p><h3 id="更容易迁移"><a href="#更容易迁移" class="headerlink" title="更容易迁移"></a>更容易迁移</h3><p>提供一致性的运行环境。已经打包好的应用可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行。</p><h3 id="更容易维护"><a href="#更容易维护" class="headerlink" title="更容易维护"></a>更容易维护</h3><p>使用分层技术和镜像，使得应用可以更容易复用重复的部分。复用程度越高，维护工作也越容易。</p><h3 id="更容易扩展"><a href="#更容易扩展" class="headerlink" title="更容易扩展"></a>更容易扩展</h3><p>可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像。</p><h2 id="四、使用场景"><a href="#四、使用场景" class="headerlink" title="四、使用场景"></a>四、使用场景</h2><h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><p>持续集成指的是频繁地将代码集成到主干上，这样能够更快地发现错误。</p><p>Docker 具有轻量级以及隔离性的特点，在将代码集成到一个 Docker 中不会对其它 Docker 产生影响。</p><h3 id="提供可伸缩的云服务"><a href="#提供可伸缩的云服务" class="headerlink" title="提供可伸缩的云服务"></a>提供可伸缩的云服务</h3><p>根据应用的负载情况，可以很容易地增加或者减少 Docker。</p><h3 id="搭建微服务架构"><a href="#搭建微服务架构" class="headerlink" title="搭建微服务架构"></a>搭建微服务架构</h3><p>Docker 轻量级的特点使得它很适合用于<strong>部署、维护、组合微服务</strong>。</p><h2 id="五、镜像与容器"><a href="#五、镜像与容器" class="headerlink" title="五、镜像与容器"></a>五、镜像与容器</h2><p>镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。</p><p>镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。</p><p>构建容器时，通过在镜像的基础上添加一个<strong>可写层</strong>（writable layer），用来保存着容器运行过程中的修改。</p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>陌生名词</title>
    <link href="/2022/08/01/%E9%99%8C%E7%94%9F%E5%90%8D%E8%AF%8D/"/>
    <url>/2022/08/01/%E9%99%8C%E7%94%9F%E5%90%8D%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="陌生名词"><a href="#陌生名词" class="headerlink" title="陌生名词"></a>陌生名词</h1><h3 id="异构"><a href="#异构" class="headerlink" title="异构"></a>异构</h3><p>即由不同的元素或部分组成，不均匀的意思。</p><h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p><em>报文</em>(message)是网络中交换与传输的数据单元，即站点一次性要发送的数据块。<em>报文</em>包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。</p><h3 id="TTL-Time-To-Live"><a href="#TTL-Time-To-Live" class="headerlink" title="TTL(Time To Live)"></a>TTL(Time To Live)</h3><p>该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。<em>TTL</em>是IPv4报头的一个8 bit字段。注意：<em>TTL</em>与DNS <em>TTL</em>有区别。二者都是生存时间，前者指ICMP包的转发次数（跳数），后者指域名解析信息在DNS中的存在时间。</p><h3 id="跳数"><a href="#跳数" class="headerlink" title="跳数"></a>跳数</h3><p>跳数实际上是一个数值（振幅），简单的说就是指一个数（空间）可以被等分成多少个另一个数（相互隔离的或抽象的或连续的空间）的值。因为跳是需要能量的给人以充满力量的摆脱束缚跨越障碍的感觉（当然干任何事情都是需要转化能量的，除非你变成空间，那么能量就不再运动，能量就变成最原始的状态），把一个数等分仍然是需要转化能量的，跳得高矮，远近受转化能量的大小控制，等份的多少也受转化能量多少的支配，能量是最具有惰性的一种物质，他有想静止不动的特性（这是由于空间这种物质都是挤压在一起的，无法动弹），也就是说无限趋向于静止，所以有把一切拉回到静止状态的趋势，为了跨越并摆脱这种障碍所需要转化的能量的大小可以与任意维数上的空间中的位置建立一一对应的关系。也就是说为了克服无限大无限小的空间的阻碍需要暂时用能量把他挤开，以获得通过或占据他们的位置。这就是为什么数列、矩阵和维度空间都无限趋向或远离某一点的原因，也就是从什么地方开始在什么地方结束的问题。但是空间的分布按照需要并不是连续的，所以需要计算“跳”到另一个空间位置上去所需要的能量的一种计量单位。</p><h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>ICMP（Internet Control Message Protocol）<strong>Internet控制报文协议</strong>。它是TCP&#x2F;IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。ICMP使用IP的基本支持，就像它是一个更高级别的协议，但是，ICMP实际上是IP的一个组成部分，必须由每个IP模块实现。</p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>直译为<strong>媒体存取控制位址</strong>，也称为<strong>局域网地址</strong>（LAN Address），<strong>MAC位址</strong>，<strong>以太网地址</strong>（Ethernet Address）或<strong>物理地址</strong>（Physical Address），它是一个用来确认网络设备位置的位址。在OSI模型中，<strong>第三层网络层负责IP地址</strong>，<strong>第二层数据链路层则负责MAC位址</strong> 。MAC地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址</p><h3 id="熟知端口"><a href="#熟知端口" class="headerlink" title="熟知端口"></a>熟知端口</h3><p>通俗地讲，熟知端口就是我们在使用网络进行通讯时常常会用到的端口，范围从0到1023。IANA把这些端口号指派给了TCP&#x2F;IP最重要的一些应用进程。当一种新的应用程序出现后，IANA必须为它指派一个熟知端口号，否则因特网上的其他应用进程就无法和它进行通信。</p><table><thead><tr><th>端口号</th><th>描述</th></tr></thead><tbody><tr><td>21</td><td><strong>FTP</strong>文件传输协议的端口号</td></tr><tr><td>23</td><td><strong>Telnet</strong>远程终端协议的端口号</td></tr><tr><td>25</td><td><strong>SMTP</strong>简单邮件传输协议的端口号</td></tr><tr><td>53</td><td><strong>DNS</strong>域服务器所开放的端口</td></tr><tr><td>69</td><td><strong>TFTP</strong>简单文件传送协议的端口号</td></tr><tr><td>80</td><td><strong>HTTP</strong>超文本传输协议的端口号</td></tr><tr><td>110</td><td><strong>POP3</strong>邮局协议版本3的端口号</td></tr><tr><td>123</td><td><strong>NTP</strong>网络时间协议的端口号</td></tr><tr><td>161</td><td><strong>SNMP</strong>简单网络管理协议 的端口号</td></tr><tr><td>520</td><td><strong>RIP</strong>路由信息协议的端口号</td></tr></tbody></table><h3 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议 (DHCP)"></a>动态主机配置协议 (DHCP)</h3><p><strong>DHCP</strong>是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。</p><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p><strong>子网掩码(subnet mask)<strong>又叫网络掩码、地址掩码、子网络遮罩，它用来指明一个</strong>IP地址</strong>的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。</p><p>子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在广域网上。</p><h3 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h3><p>对于一般由路由器和主机组成的互连系统，我们可以使用下列方法定义系统中的子网。</p><p>为了确定网络区域，分开主机和路由器的每个接口，从而产生了若干个分离的网络岛，接口端连接了这些独立网络的端点。这些独立的网络岛叫做<strong>子网(subnet)。</strong></p><p>IP地址是以网络号和主机号来表示网络上的主机的，只有在一个网络号下的计算机之间才能“直接”互通，不同网络号的计算机要通过网关（Gateway）才能互通。但这样的划分在某些情况下显得并不十分灵活。为此IP网络还允许划分成更小的网络，称为子网（Subnet）。</p><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关(Gateway)又称网间连接器、协议转换器。网关在<strong>网络层</strong>以上实现网络互连，是复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。 网关是一种充当转换重任的计算机系统或设备。使用在不同的通讯协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。同层–应用层。</p><h3 id="中断代理"><a href="#中断代理" class="headerlink" title="中断代理"></a>中断代理</h3><p>中继代理:如果DHCP 客户端和DHCP 服务器都位于<strong>同一个网段</strong>内，客户端获取IP 地址的过程与描述的基本相同。但是，如果DHCP 客户端和DHCP 服务器位于被一个或多个路由器分展开的<strong>不同的网段</strong>上，整个过程就会变得更复杂一些。路由器通常是不能将广播发送到其他网络上的。为了DHCP 可以工作，需要有一个中介来协助完成DHCP 的处理过程。这个中介是与DHCP 客户端在相同网络中的另一台主机(通常就是路由器)。</p><p>中继代理必须具有固定的IP地址，同时还保存有DHCP 服务器的IP 地址。因为中继代理已经拥有IP 地址，<strong>所以可以直接向DHCP 服务器发送数据包，或者接收来自于DHCP服务器的数据包</strong>。由于中继代理与DHCP 客户端位于相同的网络上，也就意味着它可以<strong>通过广播与DHCP客户端进行通信</strong>。</p><p>中继代理会在UDP端口监听广播；<strong>当中继代理检测到DHCP请求时，就将这个请求转发给DHCP服务器。当代理收到DHCP服务器的响应时，就将响应在本地网段上广播</strong>。</p><p>一种很流行这做法是通过路由器提供DHCP服务器的功能，在大多数网络中，这样都可以减少对DHCP中继代理的需求。</p><h3 id="HTTP首部查询"><a href="#HTTP首部查询" class="headerlink" title="HTTP首部查询"></a>HTTP首部查询</h3><h4 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存的行为</td></tr><tr><td>Connection</td><td>控制不再转发给代理的首部字段、管理持久连接</td></tr><tr><td>Date</td><td>创建报文的日期时间</td></tr><tr><td>Pragma</td><td>报文指令</td></tr><tr><td>Trailer</td><td>报文末端的首部一览</td></tr><tr><td>Transfer-Encoding</td><td>指定报文主体的传输编码方式</td></tr><tr><td>Upgrade</td><td>升级为其他协议</td></tr><tr><td>Via</td><td>代理服务器的相关信息</td></tr><tr><td>Warning</td><td>错误通知</td></tr></tbody></table><h4 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept</td><td>用户代理可处理的媒体类型</td></tr><tr><td>Accept-Charset</td><td>优先的字符集</td></tr><tr><td>Accept-Encoding</td><td>优先的内容编码</td></tr><tr><td>Accept-Language</td><td>优先的语言（自然语言）</td></tr><tr><td>Authorization</td><td>Web 认证信息</td></tr><tr><td>Expect</td><td>期待服务器的特定行为</td></tr><tr><td>From</td><td>用户的电子邮箱地址</td></tr><tr><td>Host</td><td>请求资源所在服务器</td></tr><tr><td>If-Match</td><td>比较实体标记（ETag）</td></tr><tr><td>If-Modified-Since</td><td>比较资源的更新时间</td></tr><tr><td>If-None-Match</td><td>比较实体标记（与 If-Match 相反）</td></tr><tr><td>If-Range</td><td>资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td>If-Unmodified-Since</td><td>比较资源的更新时间（与 If-Modified-Since 相反）</td></tr><tr><td>Max-Forwards</td><td>最大传输逐跳数</td></tr><tr><td>Proxy-Authorization</td><td>代理服务器要求客户端的认证信息</td></tr><tr><td>Range</td><td>实体的字节范围请求</td></tr><tr><td>Referer</td><td>对请求中 URI 的原始获取方</td></tr><tr><td>TE</td><td>传输编码的优先级</td></tr><tr><td>User-Agent</td><td>HTTP 客户端程序的信息</td></tr></tbody></table><h4 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>是否接受字节范围请求</td></tr><tr><td>Age</td><td>推算资源创建经过时间</td></tr><tr><td>ETag</td><td>资源的匹配信息</td></tr><tr><td>Location</td><td>令客户端重定向至指定 URI</td></tr><tr><td>Proxy-Authenticate</td><td>代理服务器对客户端的认证信息</td></tr><tr><td>Retry-After</td><td>对再次发起请求的时机要求</td></tr><tr><td>Server</td><td>HTTP 服务器的安装信息</td></tr><tr><td>Vary</td><td>代理服务器缓存的管理信息</td></tr><tr><td>WWW-Authenticate</td><td>服务器对客户端的认证信息</td></tr></tbody></table><h4 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Allow</td><td>资源可支持的 HTTP 方法</td></tr><tr><td>Content-Encoding</td><td>实体主体适用的编码方式</td></tr><tr><td>Content-Language</td><td>实体主体的自然语言</td></tr><tr><td>Content-Length</td><td>实体主体的大小</td></tr><tr><td>Content-Location</td><td>替代对应资源的 URI</td></tr><tr><td>Content-MD5</td><td>实体主体的报文摘要</td></tr><tr><td>Content-Range</td><td>实体主体的位置范围</td></tr><tr><td>Content-Type</td><td>实体主体的媒体类型</td></tr><tr><td>Expires</td><td>实体主体过期的日期时间</td></tr><tr><td>Last-Modified</td><td>资源的最后修改日期时间</td></tr></tbody></table><h3 id="SSL-安全套接层"><a href="#SSL-安全套接层" class="headerlink" title="SSL(安全套接层)"></a>SSL(安全套接层)</h3><p>SSL（Secure Socket Layer）安全套接层是Netscape公司率先采用的网络安全协议。它是在传输通信协议（TCP&#x2F;IP）上实现的一种安全协议，采用公开密钥技术。SSL广泛支持各种类型的网络，同时提供三种基本的安全服务，它们都使用公开密钥技术。</p><h3 id="Socket-套接字"><a href="#Socket-套接字" class="headerlink" title="Socket (套接字)"></a>Socket (套接字)</h3><p>所谓套接字(Socket)，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议栈进行交互的接口。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络基础</tag>
      
      <tag>专业名词</tag>
      
      <tag>查询</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络基础</title>
    <link href="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%95.md">资料来源</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h3><p>网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。</p><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p>网络业务提供商，互联网服务提供商，即<strong>向广大用户综合提供互联网接入业务、信息业务、和增值业务的电信运营商</strong>。在互联网应用服务产业链“设备供应商——基础网络运营商——内容收集者和生产者——业务提供者——用户”中，ISP处于内容收集者、生产者以及业务提供者的位置。</p><p>互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220713230839808.png" alt="image-20220713230839808" style="zoom:67%;"><p>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 <strong>IXP</strong>(<em>一般指互联网交换中心。 互联网交换中心是不同电信运营商之间为连通各自网络而建立的集中交换平台</em>) 允许两个 ISP 直接相连而不用经过第三个 ISP。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220713231408342.png" alt="image-20220713231408342" style="zoom:67%;"><h3 id="主机之间的通信方式"><a href="#主机之间的通信方式" class="headerlink" title="主机之间的通信方式"></a>主机之间的通信方式</h3><ul><li><p>客户-服务器（C&#x2F;S）：客户是服务的请求方，服务器是服务的提供方。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220713231749495.png" alt="image-20220713231749495" style="zoom:67%;"></li><li><p>对等（P2P）：不区分客户和服务器。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220713231833114.png" alt="image-20220713231833114" style="zoom:67%;"></li></ul><h3 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h3><ul><li><p><strong>电路交换</strong>：电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p></li><li><p><strong>分组交换</strong>：每个分组都有首部和尾部，包含了<strong>源地址和目的地址</strong>等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</p><p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p></li></ul><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>总时延&#x3D;排队时延+处理时延+传输时延+传播时延</p><ul><li><p><strong>排队时延</strong>：分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</p></li><li><p><strong>处理时延</strong>：主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</p></li><li><p><strong>传输时延</strong>：主机或路由器传输数据帧所需要的时间。<br>$$<br>delay&#x3D;l(bit)&#x2F;v(bit&#x2F;s)<br>$$<br>其中l表示数据帧的长度，v表示传输速率。</p></li><li><p><strong>传播时延</strong>：电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。<br>$$<br>delay&#x3D;l(m)&#x2F;v(m&#x2F;s)<br>$$<br>其中l表示信道长度，v表示电磁波在信道上的传播速度。</p></li></ul><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220713233341776.png" alt="image-20220713233341776" style="zoom:67%;"><ol><li><p><strong>OSI</strong></p><p>开放式系统互联通信参考模型，一个试图使各种计算机在世界范围内互连为网络的标准框架。</p><p>其中表示层和会话层用途如下：</p><ul><li><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li><li><strong>会话层</strong> ：建立及管理会话。</li></ul><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p></li><li><p><strong>五层协议</strong></p><ul><li><strong>应用层</strong>：为特定应用程序提供数据传输服务，例如HTTP、DNS等协议。数据单位为报文。</li><li><strong>传输层</strong>：为<strong>进程</strong>提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。传输层包括两种协议：传输控制协议<strong>TCP</strong>、提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议<strong>UDP</strong>，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。<strong>TCP主要提供完整性服务，UDP主要提供即时性服务。</strong></li><li><strong>网络层</strong>：为<strong>主机</strong>提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li><li><strong>数据链路层</strong>：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是<strong>为同一链路的主机提供数据传输服务</strong>。数据链路层把网络层传下来的分组封装成帧。</li><li><strong>物理层</strong>：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是<strong>尽可能屏蔽传输媒体和通信手段的差异</strong>，使数据链路层感觉不到这些差异。</li></ul></li><li><p><strong>TCP&#x2F;IP</strong></p><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP&#x2F;IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220713235308339.png" alt="image-20220713235308339" style="zoom:67%;"></li><li><p><strong>数据在各层之间的传递过程</strong></p><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p></li></ol><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p><ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul><h3 id="带通调制"><a href="#带通调制" class="headerlink" title="带通调制"></a>带通调制</h3><p>模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。</p><h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><h3 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h3><h4 id="1-封装成帧"><a href="#1-封装成帧" class="headerlink" title="1. 封装成帧"></a>1. 封装成帧</h4><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32396131343733352d653135342d346636302d396130342d6339363238653564303966342e706e67.png" alt="img" style="zoom:67%;"><h4 id="2-透明传输"><a href="#2-透明传输" class="headerlink" title="2. 透明传输"></a>2. 透明传输</h4><p>透明表示一个实际存在的事物看起来好像不存在一样。</p><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65373338613364322d663432652d343735352d616531332d6361323334393765376139372e706e67.png" alt="img" style="zoom:67%;"><h4 id="3-差错检测"><a href="#3-差错检测" class="headerlink" title="3. 差错检测"></a>3. 差错检测</h4><p>目前数据链路层广泛使用了<strong>循环冗余检验</strong>（CRC）来检查比特差错。</p><p>（<em>循环冗余校验</em>是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。）</p><h3 id="信道分类"><a href="#信道分类" class="headerlink" title="信道分类"></a>信道分类</h3><h4 id="1-广播信道"><a href="#1-广播信道" class="headerlink" title="1. 广播信道"></a>1. 广播信道</h4><p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用<strong>信道复用技术</strong>，一是使用 <strong>CSMA&#x2F;CD 协议</strong>。</p><p>（信道复用技术，比如，传输的语音信号的频谱一般在300~3400Hz内，为了使若干个这种信号能在同一信道上传输，可以把它们的频谱调制到不同的频段，合并在一起而不致相互影响，并能在接收端彼此分离开来。）</p><p>（CSMA&#x2F;CD协议，所有节点都共享网络传输信道，节点在发送数据之前，首先检测信道是否空闲，如果信道空闲则发送，否则就等待；在发送出信息后，再对冲突进行检测，当发现冲突时，则取消发送。）</p><h4 id="2-点对点信道"><a href="#2-点对点信道" class="headerlink" title="2. 点对点信道"></a>2. 点对点信道</h4><p>一对一通信。</p><p>因为不会发生碰撞，因此也比较简单，使用 <strong>PPP 协议</strong>（点对点协议）进行控制。</p><h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><ul><li><p><strong>频分复用</strong></p><p>频分复用的所有主机在相同的时间占用不同的频率带宽资源。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220718161257924.png" alt="image-20220718161257924" style="zoom:67%;"></li><li><p><strong>时分复用</strong></p><p>时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220718161407497.png" alt="image-20220718161407497" style="zoom:67%;"><p>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。</p></li><li><p><strong>统计时分复用</strong></p><p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220718161604066.png" alt="image-20220718161604066" style="zoom:67%;"></li><li><p><strong>波分复用</strong></p><p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p></li><li><p><strong>码分复用</strong></p><p>为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 <img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f5c7665637b537d.gif" alt="img"> 和 <img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/../../../%25E7%25AC%2594%25E8%25AE%25B0/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C%25E5%259F%25BA%25E7%25A1%2580/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f5c7665637b547d.gif" alt="img"> 有</p><p><a href="https://camo.githubusercontent.com/8b08ea3e94cc2d91bf6b52fc37521822bbc4700ed634ce3528280afcd33ebe0a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33303861303265392d333334362d343235312d386334312d6264353533366461623439312e706e67"><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33303861303265392d333334362d343235312d386334312d6264353533366461623439312e706e67.png" alt="img" style="zoom: 50%;"></a></p><p>为了讨论方便，取 m&#x3D;8，设码片 <img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f5c7665637b537d.gif" alt="img"> 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。</p><p>在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36666461316463372d356337342d343963312d626237392d3233376137376534336134332e706e67.png" alt="img" style="zoom:50%;"><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65333235613930332d663062312d346662642d383262662d3838393133646332663239302e706e67.png" alt="img" style="zoom:50%;"><p>其中 <img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/../../../%25E7%25AC%2594%25E8%25AE%25B0/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C%25E5%259F%25BA%25E7%25A1%2580/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f5c7665637b53277d.gif" alt="img">为 <img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f5c7665637b537d.gif" alt="img">的反码。</p><p>利用上面的式子我们知道，当接收端使用码片 <img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f5c7665637b537d.gif" alt="img">对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。</p><p>码分复用需要发送的数据量为原先的 m 倍。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220718162004759.png" alt="image-20220718162004759" style="zoom:67%;"></li></ul><h3 id="CSMA-x2F-CD协议"><a href="#CSMA-x2F-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h3><p>CSMA&#x2F;CD 表示载波监听多点接入 &#x2F; 碰撞检测。</p><ul><li><strong>多点接入</strong> ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li><li><strong>载波监听</strong> ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li><li><strong>碰撞检测</strong> ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li></ul><p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 <strong>争用期</strong> 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 <strong>截断二进制指数退避算法</strong> 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220718163829539.png" alt="image-20220718163829539" style="zoom:67%;"><h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><p>PPP 的帧格式：</p><ul><li>F 字段为帧的定界符</li><li>A 和 C 字段暂时没有意义</li><li>FCS 字段是使用 CRC 的检验序列</li><li>信息部分的长度不超过 1500</li></ul><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220718164004274.png" alt="image-20220718164004274" style="zoom:67%;"><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p><p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p><p>可以按照网络拓扑结构对局域网进行分类：</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220718164342708.png" alt="image-20220718164342708" style="zoom:67%;"><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>以太网是一种星型拓扑结构局域网。</p><p>早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。</p><p>目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p><p>以太网帧格式：</p><ul><li><strong>类型</strong> ：标记上层使用的协议；</li><li><strong>数据</strong> ：长度在 46-1500 之间，如果太小则需要填充；</li><li><strong>FCS</strong> ：帧检验序列，使用的是 CRC 检验方法；</li></ul><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220718164504625.png" alt="image-20220718164504625" style="zoom:67%;"><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p><p>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p><p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220718164633070.png" alt="image-20220718164633070" style="zoom:67%;"><h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。</p><p>例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。</p><p>使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220718164814470.png" alt="image-20220718164814470" style="zoom:67%;"><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</p><p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ul><h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h3><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220801095910458.png" alt="image-20220801095910458" style="zoom:67%;"><ul><li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li><li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li><li><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</li><li><strong>总长度</strong> : 包括首部长度和数据部分长度。</li><li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li><li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li><li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li><li><strong>标识</strong> : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li><li><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li></ul><p>以下为数据报的分片举例</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220801100018638.png" alt="image-20220801100018638" style="zoom:67%;"><h3 id="IP地址编制方式"><a href="#IP地址编制方式" class="headerlink" title="IP地址编制方式"></a>IP地址编制方式</h3><p>IP 地址的编址方式经历了三个历史阶段：</p><ul><li>分类</li><li>子网划分</li><li>无分类</li></ul><ol><li><p><strong>分类</strong></p><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><p>IP地址 ::&#x3D; {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220801100533258.png" alt="image-20220801100533258" style="zoom:67%;"></li><li><p>**子网划分 ***</p><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p><p>IP 地址 ::&#x3D; {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p><p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p><p>注意，外部网络看不到子网的存在。</p></li><li><p><strong>无分类</strong></p><p>无分类编址CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p><p>IP 地址 ::&#x3D; {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p><p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7&#x2F;20 表示前 20 位为网络前缀。</p><p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 <strong>构成超网</strong> 。</p><p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p></li></ol><h3 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h3><p><strong>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信</strong>。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220801102101461.png" alt="image-20220801102101461" style="zoom:67%;"><p>ARP实现由IP地址得到MAC地址</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220801102143494.png" alt="image-20220801102143494" style="zoom:67%;"><p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p><p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220801103212211.png" alt="image-20220801103212211" style="zoom:67%;"><h3 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h3><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220801103539572.png" alt="image-20220801103539572" style="zoom:67%;"><p>ICMP 报文分为差错报告报文和询问报文。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220801103611925.png" alt="image-20220801103611925" style="zoom:67%;"><ol><li><p><strong>Ping</strong></p><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p></li><li><p><strong>Traceroute</strong>*</p><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p><p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul></li></ol><h3 id="虚拟专用网VPN"><a href="#虚拟专用网VPN" class="headerlink" title="虚拟专用网VPN"></a>虚拟专用网VPN</h3><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p><p>有三个专用地址块：</p><ul><li>10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 ~ 192.168.255.255</li></ul><p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p><p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220801104911050.png" alt="image-20220801104911050" style="zoom:67%;"><h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220801105007913.png" alt="image-20220801105007913" style="zoom:67%;"><h3 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h3><p>路由器从功能上可以划分为：路由选择和分组转发。</p><p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220801105402645.png" alt="image-20220801105402645" style="zoom:67%;"><h3 id="路由器分组转发流程"><a href="#路由器分组转发流程" class="headerlink" title="路由器分组转发流程"></a>路由器分组转发流程</h3><ul><li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li><li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li><li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li><li>报告转发分组出错。</li></ul><h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议*"></a>路由选择协议*</h3><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p><p>可以把路由选择协议划分为两大类：</p><ul><li>自治系统内部的路由选择：RIP 和 OSPF</li><li>自治系统间的路由选择：BGP</li></ul><ol><li><p><strong>内部网关协议RIP</strong></p><p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p><p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p><p>距离向量算法：</p><ul><li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li><li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li><li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li><li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li></ul><p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p></li><li><p><strong>内部网关协议OSPF</strong></p><p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p><p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p><p>OSPF 具有以下特点：</p><ul><li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li><li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li><li>只有当链路状态发生变化时，路由器才会发送信息。</li></ul><p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p></li><li><p><strong>外部网关协议BGP</strong></p><p>BGP（Border Gateway Protocol，边界网关协议）</p><p>AS 之间的路由选择很困难，主要是由于：</p><ul><li>互联网规模很大；</li><li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li><li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li></ul><p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p><p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p></li></ol><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p><h3 id="UDP和TCP的特点"><a href="#UDP和TCP的特点" class="headerlink" title="UDP和TCP的特点"></a>UDP和TCP的特点</h3><ul><li><strong>用户数据报协议 UDP</strong>（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li><li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li></ul><h3 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h3><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220801111104326.png" alt="image-20220801111104326" style="zoom:67%;"><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><h3 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h3><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220801111159021.png" alt="image-20220801111159021" style="zoom:67%;"><ul><li><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li><li><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li><li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li><strong>确认 ACK</strong> ：当 ACK&#x3D;1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN&#x3D;1，ACK&#x3D;0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN&#x3D;1，ACK&#x3D;1。</li><li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN&#x3D;1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li><li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li></ul><h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220801111821752.png" alt="image-20220801111821752" style="zoom:67%;"><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN&#x3D;1，ACK&#x3D;0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN&#x3D;1，ACK&#x3D;1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><p><strong>三次握手的原因</strong></p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220801112236482.png" alt="image-20220801112236482" style="zoom:67%;"><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li>A 发送连接释放报文，FIN&#x3D;1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN&#x3D;1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><p><strong>四次挥手的原因</strong></p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME_WAIT</strong></p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><h3 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h3><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><h3 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口*"></a>TCP滑动窗口*</h3><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220801113057308.png" alt="image-20220801113057308" style="zoom:67%;"><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制*"></a>TCP拥塞控制*</h3><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220801113307183.png" alt="image-20220801113307183" style="zoom:67%;"><p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p><p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><p>为了便于讨论，做如下假设：</p><ul><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ul><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220801113736612.png" alt="image-20220801113736612" style="zoom:67%;"><ol><li><p><strong>慢开始于拥塞避免</strong></p><p>发送的最初执行慢开始，令 cwnd &#x3D; 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;&#x3D; ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时，则令 ssthresh &#x3D; cwnd &#x2F; 2，然后重新执行慢开始。</p></li><li><p><strong>快重传与快恢复</strong></p><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p><p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh &#x3D; cwnd &#x2F; 2 ，cwnd &#x3D; ssthresh，注意到此时直接进入拥塞避免。</p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220801113901005.png" alt="image-20220801113901005" style="zoom:67%;"></li></ol><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h3><p>DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p><p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p><p>DNS 可以使用 UDP 或者 TCP 进行传输，<strong>使用的端口号都为 53</strong>。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：</p><ul><li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li><li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li></ul><h3 id="文件传送协议"><a href="#文件传送协议" class="headerlink" title="文件传送协议"></a>文件传送协议</h3><p>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</p><ul><li><strong>控制连接</strong>：服务器打开<strong>端口号 21</strong>（用于FTP连接服务）等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li><li><strong>数据连接</strong>：用来传送一个文件数据。</li></ul><p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p><ul><li><p><strong>主动模式</strong>：服务器端主动建立数据连接，其中服务器端的<strong>端口号为 20</strong>（用于FTP传输服务），客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</p></li><li><p><strong>被动模式</strong>：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</p></li></ul><p><strong>主动模式</strong>要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。<strong>被动模式</strong>只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的<strong>安全性减弱</strong>，因为开放了过多的端口号。</p><h3 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议 (DHCP)"></a>动态主机配置协议 (DHCP)</h3><p><strong>DHCP</strong>是一个局域网的网络协议。指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。</p><p>DHCP 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</p><p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p><p>DHCP 工作过程如下：</p><ol><li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用<strong>中继代理</strong>。</li><li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li><li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li><li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li></ol><h3 id="远程登录协议-Telnet"><a href="#远程登录协议-Telnet" class="headerlink" title="远程登录协议 (Telnet)"></a>远程登录协议 (Telnet)</h3><p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p><p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p><h3 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h3><p>一个电子邮件系统由三部分组成：<strong>用户代理</strong>、<strong>邮件服务器</strong>以及<strong>邮件协议</strong>。</p><p>邮件协议包含发送协议和读取协议，<strong>发送协议</strong>常用 SMTP，<strong>读取协议</strong>常用 POP3 和 IMAP。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220804094729500.png" alt="image-20220804094729500" style="zoom:67%;"><ul><li><p><strong>SMTP</strong></p><p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220804094825471.png" alt="image-20220804094825471" style="zoom:67%;"></li><li><p><strong>POP3</strong></p><p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。</p></li><li><p><strong>IMAP</strong></p><p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p></li></ul><h3 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h3><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>应用</td><td>应用层协议</td><td>端口号</td><td>传输层协议</td><td>备注</td></tr><tr><td>域名解析</td><td>DNS</td><td>53</td><td>UDP&#x2F;TCP</td><td>长度超过 512 字节时使用 TCP</td></tr><tr><td>动态主机配置协议</td><td>DHCP</td><td>67&#x2F;68</td><td>UDP</td><td></td></tr><tr><td>简单网络管理协议</td><td>SNMP</td><td>161&#x2F;162</td><td>UDP</td><td></td></tr><tr><td>文件传送协议</td><td>FTP</td><td>20&#x2F;21</td><td>TCP</td><td>控制连接 21，数据连接 20</td></tr><tr><td>远程终端协议</td><td>TELNET</td><td>23</td><td>TCP</td><td></td></tr><tr><td>超文本传送协议</td><td>HTTP</td><td>80</td><td>TCP</td><td></td></tr><tr><td>简单邮件传送协议</td><td>SMTP</td><td>25</td><td>TCP</td><td></td></tr><tr><td>邮件读取协议</td><td>POP3</td><td>110</td><td>TCP</td><td></td></tr><tr><td>网际报文存取协议</td><td>IMAP</td><td>143</td><td>TCP</td><td></td></tr></tbody></table><h3 id="WEB页面请求过程"><a href="#WEB页面请求过程" class="headerlink" title="WEB页面请求过程"></a>WEB页面请求过程</h3><h4 id="1-DHCP-配置主机信息"><a href="#1-DHCP-配置主机信息" class="headerlink" title="1. DHCP 配置主机信息"></a>1. DHCP 配置主机信息</h4><ul><li>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</li><li>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</li><li>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</li><li>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:&lt;zero-width space&gt;FF:&lt;zero-width space&gt;FF:&lt;zero-width space&gt;FF:&lt;zero-width space&gt;FF:FF，将广播到与交换机连接的所有设备。</li><li>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</li><li>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</li><li>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</li></ul><h4 id="2-ARP-解析-MAC-地址"><a href="#2-ARP-解析-MAC-地址" class="headerlink" title="2. ARP 解析 MAC 地址"></a>2. ARP 解析 MAC 地址</h4><ul><li>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</li><li>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</li><li>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</li><li>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</li><li>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</li><li>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:&lt;zero-width space&gt;FF:&lt;zero-width space&gt;FF:&lt;zero-width space&gt;FF:&lt;zero-width space&gt;FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</li><li>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</li></ul><h4 id="3-DNS-解析域名"><a href="#3-DNS-解析域名" class="headerlink" title="3. DNS 解析域名"></a>3. DNS 解析域名</h4><ul><li>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</li><li>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</li><li>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</li><li>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</li><li>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</li></ul><h4 id="4-HTTP-请求页面"><a href="#4-HTTP-请求页面" class="headerlink" title="4. HTTP 请求页面"></a>4. HTTP 请求页面</h4><ul><li>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</li><li>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</li><li>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</li><li>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</li><li>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</li><li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><h4 id="请求和响应报文"><a href="#请求和响应报文" class="headerlink" title="请求和响应报文"></a>请求和响应报文</h4><p>客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。</p><p>请求报文结构：</p><ul><li>第一行是包含了请求方法、URL、协议版本；</li><li>接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。</li><li>一个空行用来分隔首部和内容主体 Body</li><li>最后是请求的内容主体</li></ul><figure class="highlight http"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">http://www.example.com/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=0<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com<br><span class="hljs-attribute">If-Modified-Since</span><span class="hljs-punctuation">: </span>Thu, 17 Oct 2019 07:18:26 GMT<br><span class="hljs-attribute">If-None-Match</span><span class="hljs-punctuation">: </span>&quot;3147526947+gzip&quot;<br><span class="hljs-attribute">Proxy-Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 xxx<br><br><span class="language-apache"><span class="hljs-attribute">param1</span>=<span class="hljs-number">1</span>&amp;param2=<span class="hljs-number">2</span></span><br></code></pre></td></tr></table></figure><p>响应报文结构：</p><ul><li>第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了</li><li>接下来多行也是首部内容</li><li>一个空行分隔首部和内容主体</li><li>最后是响应的内容主体</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Age</span><span class="hljs-punctuation">: </span>529651<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=604800<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>gzip<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>648<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=UTF-8<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 02 Nov 2020 17:53:39 GMT<br><span class="hljs-attribute">Etag</span><span class="hljs-punctuation">: </span>&quot;3147526947+ident+gzip&quot;<br><span class="hljs-attribute">Expires</span><span class="hljs-punctuation">: </span>Mon, 09 Nov 2020 17:53:39 GMT<br><span class="hljs-attribute">Keep-Alive</span><span class="hljs-punctuation">: </span>timeout=4<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Thu, 17 Oct 2019 07:18:26 GMT<br><span class="hljs-attribute">Proxy-Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>ECS (sjc/16DF)<br><span class="hljs-attribute">Vary</span><span class="hljs-punctuation">: </span>Accept-Encoding<br><span class="hljs-attribute">X-Cache</span><span class="hljs-punctuation">: </span>HIT<br><br><span class="language-xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Example Domain<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">// 省略... </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>HTTP 使用 URL（ <strong>U</strong> niform <strong>R</strong>esource <strong>L</strong>ocator，统一资源定位符）来定位资源，它是 URI（<strong>U</strong>niform <strong>R</strong>esource <strong>I</strong>dentifier，统一资源标识符）的子集，URL 在 URI 的基础上增加了定位能力。URI 除了包含 URL，还包含 URN（Uniform Resource Name，统一资源名称），它只是用来定义一个资源的名称，并不具备定位该资源的能力。例如 urn:isbn:0451450523 用来定义一个书籍名称，但是却没有表示怎么找到这本书。</p><h3 id="二、HTTP方法"><a href="#二、HTTP方法" class="headerlink" title="二、HTTP方法"></a>二、HTTP方法</h3><p>客户端发送的 <strong>请求报文</strong> 第一行为请求行，包含了方法字段。</p><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><blockquote><p>获取资源</p></blockquote><p>当前网络请求中，绝大部分使用的是 GET 方法。</p><h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><blockquote><p>获取报文首部</p></blockquote><p>和 GET 方法类似，但是不返回报文实体主体部分。</p><p>主要用于确认 URL 的有效性以及资源更新的日期时间等。</p><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><blockquote><p>传输实体主体</p></blockquote><p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p><h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><blockquote><p>上传文件</p></blockquote><p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">PUT</span> <span class="hljs-string">/new.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Content-type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Content-length</span><span class="hljs-punctuation">: </span>16<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>New File<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h4><blockquote><p>对资源进行部分修改</p></blockquote><p>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">PATCH</span> <span class="hljs-string">/file.txt</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/example<br><span class="hljs-attribute">If-Match</span><span class="hljs-punctuation">: </span>&quot;e0023aa4e&quot;<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>100<br><br><span class="language-angelscript"><span class="hljs-string">[description of changes]</span></span><br></code></pre></td></tr></table></figure><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><blockquote><p>删除文件</p></blockquote><p>与 PUT 功能相反，并且同样不带验证机制。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">DELETE</span> <span class="hljs-string">/file.html</span> <span class="hljs-meta">HTTP/1.1</span><br></code></pre></td></tr></table></figure><h4 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h4><blockquote><p>查询支持的方法</p></blockquote><p>查询指定的 URL 能够支持的方法。</p><p>会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p><h4 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h4><blockquote><p>要求在与代理服务器通信时建立隧道</p></blockquote><p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">CONNECT</span> <span class="hljs-string">www.example.com:443</span> <span class="hljs-meta">HTTP/1.1</span><br></code></pre></td></tr></table></figure><h4 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h4><blockquote><p>追踪路径</p></blockquote><p>服务器会将通信路径返回给客户端。</p><p>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。</p><p>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p><h3 id="三、HTTP状态码"><a href="#三、HTTP状态码" class="headerlink" title="三、HTTP状态码"></a>三、HTTP状态码</h3><p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table><thead><tr><th>状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><h4 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h4><ul><li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><h4 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h4><ul><li><strong>200 OK</strong></li><li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li><li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li></ul><h4 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h4><ul><li><strong>301 Moved Permanently</strong> ：永久性重定向</li><li><strong>302 Found</strong> ：临时性重定向</li><li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li><li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li><li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li><li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li></ul><h4 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h4><ul><li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li><li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403 Forbidden</strong> ：请求被拒绝。</li><li><strong>404 Not Found</strong></li></ul><h4 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h4><ul><li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li><li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul><h3 id="四、HTTP首部"><a href="#四、HTTP首部" class="headerlink" title="四、HTTP首部"></a>四、HTTP首部</h3><p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p><p>各种首部字段及其含义如下（不需要全记，仅供查阅）：</p><h4 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存的行为</td></tr><tr><td>Connection</td><td>控制不再转发给代理的首部字段、管理持久连接</td></tr><tr><td>Date</td><td>创建报文的日期时间</td></tr><tr><td>Pragma</td><td>报文指令</td></tr><tr><td>Trailer</td><td>报文末端的首部一览</td></tr><tr><td>Transfer-Encoding</td><td>指定报文主体的传输编码方式</td></tr><tr><td>Upgrade</td><td>升级为其他协议</td></tr><tr><td>Via</td><td>代理服务器的相关信息</td></tr><tr><td>Warning</td><td>错误通知</td></tr></tbody></table><h4 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept</td><td>用户代理可处理的媒体类型</td></tr><tr><td>Accept-Charset</td><td>优先的字符集</td></tr><tr><td>Accept-Encoding</td><td>优先的内容编码</td></tr><tr><td>Accept-Language</td><td>优先的语言（自然语言）</td></tr><tr><td>Authorization</td><td>Web 认证信息</td></tr><tr><td>Expect</td><td>期待服务器的特定行为</td></tr><tr><td>From</td><td>用户的电子邮箱地址</td></tr><tr><td>Host</td><td>请求资源所在服务器</td></tr><tr><td>If-Match</td><td>比较实体标记（ETag）</td></tr><tr><td>If-Modified-Since</td><td>比较资源的更新时间</td></tr><tr><td>If-None-Match</td><td>比较实体标记（与 If-Match 相反）</td></tr><tr><td>If-Range</td><td>资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td>If-Unmodified-Since</td><td>比较资源的更新时间（与 If-Modified-Since 相反）</td></tr><tr><td>Max-Forwards</td><td>最大传输逐跳数</td></tr><tr><td>Proxy-Authorization</td><td>代理服务器要求客户端的认证信息</td></tr><tr><td>Range</td><td>实体的字节范围请求</td></tr><tr><td>Referer</td><td>对请求中 URI 的原始获取方</td></tr><tr><td>TE</td><td>传输编码的优先级</td></tr><tr><td>User-Agent</td><td>HTTP 客户端程序的信息</td></tr></tbody></table><h4 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>是否接受字节范围请求</td></tr><tr><td>Age</td><td>推算资源创建经过时间</td></tr><tr><td>ETag</td><td>资源的匹配信息</td></tr><tr><td>Location</td><td>令客户端重定向至指定 URI</td></tr><tr><td>Proxy-Authenticate</td><td>代理服务器对客户端的认证信息</td></tr><tr><td>Retry-After</td><td>对再次发起请求的时机要求</td></tr><tr><td>Server</td><td>HTTP 服务器的安装信息</td></tr><tr><td>Vary</td><td>代理服务器缓存的管理信息</td></tr><tr><td>WWW-Authenticate</td><td>服务器对客户端的认证信息</td></tr></tbody></table><h4 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Allow</td><td>资源可支持的 HTTP 方法</td></tr><tr><td>Content-Encoding</td><td>实体主体适用的编码方式</td></tr><tr><td>Content-Language</td><td>实体主体的自然语言</td></tr><tr><td>Content-Length</td><td>实体主体的大小</td></tr><tr><td>Content-Location</td><td>替代对应资源的 URI</td></tr><tr><td>Content-MD5</td><td>实体主体的报文摘要</td></tr><tr><td>Content-Range</td><td>实体主体的位置范围</td></tr><tr><td>Content-Type</td><td>实体主体的媒体类型</td></tr><tr><td>Expires</td><td>实体主体过期的日期时间</td></tr><tr><td>Last-Modified</td><td>资源的最后修改日期时间</td></tr></tbody></table><h3 id="五、具体应用"><a href="#五、具体应用" class="headerlink" title="五、具体应用"></a>五、具体应用</h3><h4 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h4><ol><li><p><strong>短链接与长连接</strong></p><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p><p><strong>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信</strong>。</p><ul><li>从 HTTP&#x2F;1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li><li>在 HTTP&#x2F;1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li></ul></li><li><p><strong>流水线</strong></p><p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p><p>流水线是在同一条长连接上<strong>连续发出请求</strong>，而不用等待响应返回，这样可以减少延迟。</p></li></ol><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP&#x2F;1.1 引入 Cookie 来保存状态信息。</p><p>Cookie 是<strong>服务器发送到用户浏览器并保存在本地的一小块数据</strong>，它会<strong>在浏览器之后向同一服务器再次发起请求时被携带上</strong>，用于<strong>告知服务端两个请求是否来自同一浏览器</strong>。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p><ol><li><p><strong>用途</strong></p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul></li><li><p><strong>创建过程</strong></p><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.0</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>yummy_cookie=choco<br><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>tasty_cookie=strawberry<br><br><span class="language-angelscript"><span class="hljs-string">[page content]</span></span><br></code></pre></td></tr></table></figure><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/sample_page.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.org<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>yummy_cookie=choco; tasty_cookie=strawberry<br></code></pre></td></tr></table></figure></li><li><p><strong>分类</strong></p><ul><li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li><li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Set</span>-Cookie: id=a3fWa; Expires=Wed, <span class="hljs-number">21</span> Oct <span class="hljs-number">2015</span> <span class="hljs-number">07</span>:<span class="hljs-number">28</span>:<span class="hljs-number">00</span> GMT;<br></code></pre></td></tr></table></figure></li><li><p><strong>作用域</strong></p><p><strong>Domain 标识指定了哪些主机可以接受 Cookie</strong>。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般<strong>包含子域名</strong>。例如，如果设置 Domain&#x3D;mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</p><p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“&#x2F;“) 作为路径分隔符，<strong>子路径也会被匹配</strong>。例如，设置 Path&#x3D;&#x2F;docs，则以下地址都会匹配：</p><ul><li>&#x2F;docs</li><li>&#x2F;docs&#x2F;Web&#x2F;</li><li>&#x2F;docs&#x2F;Web&#x2F;HTTP</li></ul></li><li><p><strong>JavaScript</strong></p><p>浏览器通过 <code>document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">document.cookie <span class="hljs-operator">=</span> <span class="hljs-string">&quot;yummy_cookie=choco&quot;</span><span class="hljs-comment">;</span><br>document.cookie <span class="hljs-operator">=</span> <span class="hljs-string">&quot;tasty_cookie=strawberry&quot;</span><span class="hljs-comment">;</span><br>console.log(document.cookie)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>HttpOnly</strong></p><p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Set</span>-Cookie: id=a3fWa; Expires=Wed, <span class="hljs-number">21</span> Oct <span class="hljs-number">2015</span> <span class="hljs-number">07</span>:<span class="hljs-number">28</span>:<span class="hljs-number">00</span> GMT; Secure; HttpOnly<br></code></pre></td></tr></table></figure></li><li><p><strong>Secure</strong></p><p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 <strong>Cookie 有其固有的不安全性</strong>，Secure 标记也无法提供确实的安全保障。</p></li><li><p><strong>Session</strong></p><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p><p>使用 Session 维护用户登录状态的过程如下：</p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，<strong>它在 Redis 中的 Key 称为 Session ID</strong>；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li><strong>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息</strong>，继续之前的业务操作。</li></ul><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p></li><li><p><strong>浏览器禁用Cookie</strong></p><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，<strong>将 Session ID 作为 URL 的参数进行传递</strong>。</p></li><li><p><strong>Cookie与Session选择</strong></p><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在<strong>考虑数据复杂性时首选 Session</strong>；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以<strong>将 Cookie 值进行加密，然后在服务器进行解密</strong>；</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li></ul></li></ol><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ol><li><p><strong>优点</strong></p><ul><li>缓解服务器压力；</li><li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li></ul></li><li><p><strong>实现方法</strong></p><ul><li>让代理服务器进行缓存；</li><li>让客户端浏览器进行缓存。</li></ul></li><li><p><strong>Cache-Control</strong></p><p>HTTP&#x2F;1.1 通过 Cache-Control 首部字段来控制缓存。</p><ul><li><p><strong>禁止进行缓存</strong></p><p>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Cache-Control:</span> <span class="hljs-literal">no</span><span class="hljs-string">-store</span><br></code></pre></td></tr></table></figure></li><li><p><strong>强制确认缓存</strong></p><p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Cache</span>-Control: no-<span class="hljs-keyword">cache</span><br></code></pre></td></tr></table></figure></li><li><p><strong>私有缓存和公有缓存</strong></p><p>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Cache</span><span class="hljs-params">-Control</span>: <span class="hljs-keyword">private</span><br></code></pre></td></tr></table></figure><p>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Cache</span><span class="hljs-params">-Control</span>: <span class="hljs-keyword">public</span><br></code></pre></td></tr></table></figure></li><li><p><strong>缓存过期机制</strong>*</p><p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p><p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Cache</span><span class="hljs-params">-Control</span>: <span class="hljs-keyword">max</span><span class="hljs-params">-age</span>=<span class="hljs-number">31536000</span><br></code></pre></td></tr></table></figure><p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Expires</span>: Wed, <span class="hljs-number">04</span> Jul <span class="hljs-number">2012</span> <span class="hljs-number">08</span>:<span class="hljs-number">26</span>:<span class="hljs-number">05</span> GMT<br></code></pre></td></tr></table></figure><ul><li>在 HTTP&#x2F;1.1 中，会优先处理 max-age 指令；</li><li>在 HTTP&#x2F;1.0 中，max-age 指令会被忽略掉。</li></ul></li></ul></li><li><p><strong>缓存验证</strong>*</p><p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">ETag:</span> <span class="hljs-string">&quot;82e22293907ce725faf67773957acd12&quot;</span><br></code></pre></td></tr></table></figure><p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-built_in">None</span><span class="hljs-operator">-</span><span class="hljs-variable">Match</span><span class="hljs-operator">:</span> <span class="hljs-string">&quot;82e22293907ce725faf67773957acd12&quot;</span><br></code></pre></td></tr></table></figure><p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Last</span>-Modified: Wed, <span class="hljs-number">21</span> Oct <span class="hljs-number">2015</span> <span class="hljs-number">07</span>:<span class="hljs-number">28</span>:<span class="hljs-number">00</span> GMT<br><span class="hljs-attribute">If</span>-Modified-Since: Wed, <span class="hljs-number">21</span> Oct <span class="hljs-number">2015</span> <span class="hljs-number">07</span>:<span class="hljs-number">28</span>:<span class="hljs-number">00</span> GMT<br></code></pre></td></tr></table></figure></li></ol><h4 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商*"></a>内容协商*</h4><p>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。</p><ol><li><p><strong>类型</strong></p><ul><li><p><strong>服务端驱动型</strong></p><p>客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。</p><p>它存在以下问题：</p><ul><li>服务器很难知道客户端浏览器的全部信息；</li><li>客户端提供的信息相当冗长（HTTP&#x2F;2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；</li><li>给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。</li></ul></li><li><p><strong>代理驱动型</strong></p><p>服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。</p></li></ul></li><li><p><strong>Vary</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Vary: <span class="hljs-keyword">Accept</span>-Language<br></code></pre></td></tr></table></figure><p>在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。</p><p>例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 <code>Vary: Accept-Language</code> 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。</p></li></ol><h4 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码*"></a>内容编码*</h4><p>内容编码将实体主体进行压缩，从而减少传输的数据量。</p><p>常用的内容编码有：gzip、compress、deflate、identity。</p><p>浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。</p><h4 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h4><ol><li><p><strong>Range</strong></p><p>在请求报文中添加 Range 首部字段指定请求的范围。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/z4d4kWk.jpg</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>i.imgur.com<br><span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>bytes=0-1023<br></code></pre></td></tr></table></figure><p>请求成功的话服务器返回的响应包含 206 Partial Content 状态码。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">HTTP/1.1</span> <span class="hljs-number">206</span> <span class="hljs-string">Partial</span> <span class="hljs-string">Content</span><br><span class="hljs-attr">Content-Range:</span> <span class="hljs-string">bytes</span> <span class="hljs-number">0</span><span class="hljs-number">-1023</span><span class="hljs-string">/146515</span><br><span class="hljs-attr">Content-Length:</span> <span class="hljs-number">1024</span><br><span class="hljs-string">...</span><br><span class="hljs-string">(binary</span> <span class="hljs-string">content)</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Accept-Ranges</strong></p><p>响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Accept</span>-Ranges: bytes<br></code></pre></td></tr></table></figure></li><li><p><strong>响应状态码</strong></p><ul><li>在请求成功的情况下，服务器会返回 206 Partial Content 状态码。</li><li>在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。</li><li>在不支持范围请求的情况下，服务器会返回 200 OK 状态码。</li></ul></li></ol><h4 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h4><p>Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。</p><h4 id="多部份对象集合"><a href="#多部份对象集合" class="headerlink" title="多部份对象集合"></a>多部份对象集合</h4><p>一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。</p><p>例如，上传多个表单时可以使用如下方式：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Content-Type: multipart/form-data; boundary=AaB03x<br><br><span class="hljs-comment">--AaB03x</span><br>Content-Disposition: form-data; <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;submit-name&quot;</span><br><br>Larry<br><span class="hljs-comment">--AaB03x</span><br>Content-Disposition: form-data; <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;files&quot;</span>; filename=<span class="hljs-string">&quot;file1.txt&quot;</span><br>Content-Type: <span class="hljs-built_in">text</span>/plain<br><br>... <span class="hljs-built_in">contents</span> <span class="hljs-keyword">of</span> file1.txt ...<br><span class="hljs-comment">--AaB03x--</span><br></code></pre></td></tr></table></figure><h4 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h4><p>HTTP&#x2F;1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。</p><h4 id="通信数据转发"><a href="#通信数据转发" class="headerlink" title="通信数据转发"></a>通信数据转发</h4><ol><li><p><strong>代理</strong></p><p>代理服务器接受客户端的请求，并且转发给其它服务器。</p><p>使用代理的主要目的是：</p><ul><li>缓存</li><li>负载均衡</li><li>网络访问控制</li><li>访问日志记录</li></ul><p>代理服务器分为正向代理和反向代理两种：</p><ul><li><p>用户察觉得到正向代理的存在。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220805110954197.png" alt="image-20220805110954197" style="zoom:67%;"></li><li><p>而反向代理一般位于内部网络中，用户察觉不到。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220805111024247.png" alt="image-20220805111024247" style="zoom:67%;"></li></ul></li><li><p><strong>网关</strong></p><p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。</p></li><li><p><strong>隧道</strong></p><p>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。</p></li></ol><h3 id="六、HTTPS"><a href="#六、HTTPS" class="headerlink" title="六、HTTPS"></a>六、HTTPS</h3><p>HTTP 有以下安全性问题：</p><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><p>HTTPS 并不是新协议，而是让 <strong>HTTP 先和 SSL（Secure Sockets Layer）通信</strong>，<strong>再由 SSL 和 TCP 通信</strong>，也就是说 HTTPS 使用了隧道进行通信。</p><p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><ol><li><p><strong>对称密钥加密</strong></p><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p><ul><li>优点：运算速度快；</li><li>缺点：无法安全地将密钥传输给通信方。</li></ul></li><li><p><strong>非对称密钥加密</strong></p><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），<strong>加密和解密使用不同的密钥</strong>。</p><p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以<strong>使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密</strong>。</p><p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p><ul><li>优点：可以更安全地将公开密钥传输给通信发送方；</li><li>缺点：运算速度慢。</li></ul></li><li><p><strong>HTTPS采用的加密方式</strong>*</p><p>上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：</p><ul><li><p><strong>使用非对称密钥加密方式</strong>，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;</p></li><li><p>获取到 Secret Key 后，再<strong>使用对称密钥加密方式进行通信</strong>，从而保证效率。（下图中的 Session Key 就是 Secret Key）</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220805112550203.png" alt="image-20220805112550203" style="zoom:67%;"></li></ul></li></ol><h4 id="认证"><a href="#认证" class="headerlink" title="认证*"></a>认证*</h4><p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p><p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p><p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220805112829548.png" alt="image-20220805112829548" style="zoom:67%;"><h4 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h4><p>SSL 提供报文摘要功能来进行完整性保护。</p><p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p><p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p><h4 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h4><ul><li>因为需要进行加密解密等过程，因此速度会更慢；</li><li>需要支付证书授权的高额费用。</li></ul><h3 id="七、HTTP-x2F-2-0"><a href="#七、HTTP-x2F-2-0" class="headerlink" title="七、HTTP&#x2F;2.0"></a>七、HTTP&#x2F;2.0</h3><h4 id="HTTP-x2F-1-x缺陷"><a href="#HTTP-x2F-1-x缺陷" class="headerlink" title="HTTP&#x2F;1.x缺陷"></a>HTTP&#x2F;1.x缺陷</h4><p>HTTP&#x2F;1.x 实现简单是以牺牲性能为代价的：</p><ul><li>客户端需要使用多个连接才能实现并发和缩短延迟；</li><li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li><li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li></ul><h4 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层*"></a>二进制分帧层*</h4><p>HTTP&#x2F;2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220805113047323.png" alt="image-20220805113047323" style="zoom:67%;"><p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p><ul><li><p>一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。</p></li><li><p>消息（Message）是与逻辑请求或响应对应的完整的一系列帧。</p></li><li><p>帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220805113236912.png" alt="image-20220805113236912" style="zoom:67%;"></li></ul><h4 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送*"></a>服务端推送*</h4><p>HTTP&#x2F;2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220805113327880.png" alt="image-20220805113327880" style="zoom:67%;"><h4 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h4><p>HTTP&#x2F;1.1 的首部带有大量信息，而且每次都要重复发送。</p><p>HTTP&#x2F;2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p><p>不仅如此，HTTP&#x2F;2.0 也使用 Huffman 编码对首部字段进行压缩。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220805113429105.png" alt="image-20220805113429105" style="zoom:67%;"><h3 id="八、HTTP-x2F-1-1新特性"><a href="#八、HTTP-x2F-1-1新特性" class="headerlink" title="八、HTTP&#x2F;1.1新特性"></a>八、HTTP&#x2F;1.1新特性</h3><ul><li>默认是长连接</li><li>支持流水线</li><li>支持同时打开多个 TCP 连接</li><li>支持虚拟主机</li><li>新增状态码 100</li><li>支持分块传输编码</li><li>新增缓存处理指令 max-age</li></ul><h3 id="九、GET和POST比较"><a href="#九、GET和POST比较" class="headerlink" title="九、GET和POST比较"></a>九、GET和POST比较</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>GET 用于获取资源，而 POST 用于传输实体主体。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p><p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">GET</span> /test/demo_form.asp?<span class="hljs-attribute">name1</span>=value1&amp;name2=value2 HTTP/1.1<br>POST /test/demo_form.asp HTTP/1.1<br>Host: w3schools.com<br><span class="hljs-attribute">name1</span>=value1&amp;name2=value2<br></code></pre></td></tr></table></figure><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p><strong>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的</strong>。</p><p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，<strong>服务器可能把这个数据存储到数据库中，因此状态也就发生了改变</strong>。</p><p><strong>安全</strong>的方法除了 GET 之外还有：HEAD、OPTIONS。</p><p><strong>不安全</strong>的方法除了 POST 之外还有 PUT、DELETE。</p><h4 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性*"></a>幂等性*</h4><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p><p>所有的安全方法也都是幂等的。</p><p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p><p>GET &#x2F;pageX HTTP&#x2F;1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GET</span> /pageX HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">GET</span> /pageX HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">GET</span> /pageX HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">GET</span> /pageX HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>POST &#x2F;add_row HTTP&#x2F;1.1 不是幂等的，如果调用多次，就会增加多行记录：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">POST</span> /add_row HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span>   -&gt; Adds a <span class="hljs-number">1</span>nd row<br><span class="hljs-attribute">POST</span> /add_row HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span>   -&gt; Adds a <span class="hljs-number">2</span>nd row<br><span class="hljs-attribute">POST</span> /add_row HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span>   -&gt; Adds a <span class="hljs-number">3</span>rd row<br></code></pre></td></tr></table></figure><p>DELETE &#x2F;idX&#x2F;delete HTTP&#x2F;1.1 是幂等的，即使不同的请求接收到的状态码不一样：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">DELETE</span> <span class="hljs-regexp">/idX/</span><span class="hljs-keyword">delete</span> HTTP/<span class="hljs-number">1.1</span>   -&gt; Returns <span class="hljs-number">200</span> <span class="hljs-keyword">if</span> idX exists<br><span class="hljs-keyword">DELETE</span> <span class="hljs-regexp">/idX/</span><span class="hljs-keyword">delete</span> HTTP/<span class="hljs-number">1.1</span>   -&gt; Returns <span class="hljs-number">404</span> as it just got deleted<br><span class="hljs-keyword">DELETE</span> <span class="hljs-regexp">/idX/</span><span class="hljs-keyword">delete</span> HTTP/<span class="hljs-number">1.1</span>   -&gt; Returns <span class="hljs-number">404</span><br></code></pre></td></tr></table></figure><h4 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h4><p>如果要对响应进行缓存，需要满足以下条件：</p><ul><li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li><li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li><li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li></ul><h4 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest*"></a>XMLHttpRequest*</h4><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p><blockquote><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p></blockquote><ul><li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li><li>而 GET 方法 Header 和 Data 会一起发送。</li></ul><h2 id="Socket-套接字"><a href="#Socket-套接字" class="headerlink" title="Socket (套接字) **"></a>Socket (套接字) **</h2><h3 id="一、I-x2F-O模型"><a href="#一、I-x2F-O模型" class="headerlink" title="一、I&#x2F;O模型"></a>一、I&#x2F;O模型</h3><p>一个<strong>输入</strong>操作通常包括两个阶段：</p><ul><li>等待数据准备好</li><li>从内核向进程复制数据</li></ul><p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p><p>Unix 有五种 I&#x2F;O 模型：</p><ul><li>阻塞式 I&#x2F;O</li><li>非阻塞式 I&#x2F;O</li><li>I&#x2F;O 复用（select 和 poll）</li><li>信号驱动式 I&#x2F;O（SIGIO）</li><li>异步 I&#x2F;O（AIO）</li></ul><h4 id="阻塞式I-x2F-O"><a href="#阻塞式I-x2F-O" class="headerlink" title="阻塞式I&#x2F;O"></a>阻塞式I&#x2F;O</h4><p>应用进程被阻塞，直到数据从<strong>内核缓冲区</strong>复制到<strong>应用进程缓冲区</strong>中才返回。</p><p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 <strong>CPU 利用率会比较高</strong>。</p><p>下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">recvfrom</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags, <span class="hljs-keyword">struct</span> sockaddr *src_addr, <span class="hljs-type">socklen_t</span> *addrlen)</span></span>;<br></code></pre></td></tr></table></figure><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220809092752384.png" alt="image-20220809092752384" style="zoom:67%;"><h4 id="非阻塞式I-x2F-O"><a href="#非阻塞式I-x2F-O" class="headerlink" title="非阻塞式I&#x2F;O"></a>非阻塞式I&#x2F;O</h4><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I&#x2F;O 是否完成，这种方式称为<strong>轮询</strong>（polling）。</p><p>由于 CPU 要处理更多的系统调用，因此这种模型的 <strong>CPU 利用率比较低</strong>。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220809093250475.png" alt="image-20220809093250475" style="zoom:67%;"><h4 id="I-x2F-O复用"><a href="#I-x2F-O复用" class="headerlink" title="I&#x2F;O复用"></a>I&#x2F;O复用</h4><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p><p>它可以让单个进程具有处理多个 I&#x2F;O 事件的能力。又被称为 Event Driven I&#x2F;O，即<strong>事件驱动 I&#x2F;O</strong>。</p><p>如果一个 Web 服务器没有 I&#x2F;O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I&#x2F;O 复用不需要进程线程创建和切换的开销，<strong>系统开销更小</strong>。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220809093753033.png" alt="image-20220809093753033" style="zoom:67%;"><h4 id="信号驱动I-x2F-O"><a href="#信号驱动I-x2F-O" class="headerlink" title="信号驱动I&#x2F;O"></a>信号驱动I&#x2F;O</h4><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p><p><strong>相比于非阻塞式 I&#x2F;O 的轮询方式，信号驱动 I&#x2F;O 的 CPU 利用率更高</strong>。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220809094418634.png" alt="image-20220809094418634" style="zoom:67%;"><h4 id="异步I-x2F-O"><a href="#异步I-x2F-O" class="headerlink" title="异步I&#x2F;O"></a>异步I&#x2F;O</h4><p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p><p>异步 I&#x2F;O 与信号驱动 I&#x2F;O 的区别在于，异步 I&#x2F;O 的信号是通知应用进程 I&#x2F;O 完成，而信号驱动 I&#x2F;O 的信号是通知应用进程可以开始 I&#x2F;O。</p><img src="/2022/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20220809094759708.png" alt="image-20220809094759708" style="zoom:67%;"><h4 id="五大I-x2F-O模型比较"><a href="#五大I-x2F-O模型比较" class="headerlink" title="五大I&#x2F;O模型比较"></a>五大I&#x2F;O模型比较</h4><ul><li>同步 I&#x2F;O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li><li>异步 I&#x2F;O：第二阶段应用进程不会阻塞。</li></ul><p>同步 I&#x2F;O 包括阻塞式 I&#x2F;O、非阻塞式 I&#x2F;O、I&#x2F;O 复用和信号驱动 I&#x2F;O ，它们的主要区别在第一个阶段。</p><p>非阻塞式 I&#x2F;O 、信号驱动 I&#x2F;O 和异步 I&#x2F;O 在第一阶段不会阻塞。</p><h3 id="二、I-x2F-O复用"><a href="#二、I-x2F-O复用" class="headerlink" title="二、I&#x2F;O复用"></a>二、I&#x2F;O复用</h3><p>select&#x2F;poll&#x2F;epoll 都是 I&#x2F;O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-type">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="hljs-keyword">struct</span> timeval *timeout)</span></span>;<br></code></pre></td></tr></table></figure><p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I&#x2F;O 操作。</p><ul><li>fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。</li><li>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</li><li>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++">fd_set fd_in, fd_out;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> tv;<br><br><span class="hljs-comment">// Reset the sets</span><br><span class="hljs-built_in">FD_ZERO</span>( &amp;fd_in );<br><span class="hljs-built_in">FD_ZERO</span>( &amp;fd_out );<br><br><span class="hljs-comment">// Monitor sock1 for input events</span><br><span class="hljs-built_in">FD_SET</span>( sock1, &amp;fd_in );<br><br><span class="hljs-comment">// Monitor sock2 for output events</span><br><span class="hljs-built_in">FD_SET</span>( sock2, &amp;fd_out );<br><br><span class="hljs-comment">// Find out which socket has the largest numeric value as select requires it</span><br><span class="hljs-type">int</span> largest_sock = sock1 &gt; sock2 ? sock1 : sock2;<br><br><span class="hljs-comment">// Wait up to 10 seconds</span><br>tv.tv_sec = <span class="hljs-number">10</span>;<br>tv.tv_usec = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// Call the select</span><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">select</span>( largest_sock + <span class="hljs-number">1</span>, &amp;fd_in, &amp;fd_out, <span class="hljs-literal">NULL</span>, &amp;tv );<br><br><span class="hljs-comment">// Check if select actually succeed</span><br><span class="hljs-keyword">if</span> ( ret == <span class="hljs-number">-1</span> )<br>    <span class="hljs-comment">// report error and abort</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( ret == <span class="hljs-number">0</span> )<br>    <span class="hljs-comment">// timeout; no event detected</span><br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">FD_ISSET</span>( sock1, &amp;fd_in ) )<br>        <span class="hljs-comment">// input event on sock1</span><br><br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">FD_ISSET</span>( sock2, &amp;fd_out ) )<br>        <span class="hljs-comment">// output event on sock2</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd *fds, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nfds, <span class="hljs-type">int</span> timeout)</span></span>;<br></code></pre></td></tr></table></figure><p>poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。</p><p>poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> &#123;<br>               <span class="hljs-type">int</span>   fd;         <span class="hljs-comment">/* file descriptor */</span><br>               <span class="hljs-type">short</span> events;     <span class="hljs-comment">/* requested events */</span><br>               <span class="hljs-type">short</span> revents;    <span class="hljs-comment">/* returned events */</span><br>           &#125;;<br><span class="hljs-comment">// The structure for two events</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> fds[<span class="hljs-number">2</span>];<br><br><span class="hljs-comment">// Monitor sock1 for input</span><br>fds[<span class="hljs-number">0</span>].fd = sock1;<br>fds[<span class="hljs-number">0</span>].events = POLLIN;<br><br><span class="hljs-comment">// Monitor sock2 for output</span><br>fds[<span class="hljs-number">1</span>].fd = sock2;<br>fds[<span class="hljs-number">1</span>].events = POLLOUT;<br><br><span class="hljs-comment">// Wait 10 seconds</span><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">poll</span>( &amp;fds, <span class="hljs-number">2</span>, <span class="hljs-number">10000</span> );<br><span class="hljs-comment">// Check if poll actually succeed</span><br><span class="hljs-keyword">if</span> ( ret == <span class="hljs-number">-1</span> )<br>    <span class="hljs-comment">// report error and abort</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( ret == <span class="hljs-number">0</span> )<br>    <span class="hljs-comment">// timeout; no event detected</span><br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-comment">// If we detect the event, zero it out so we can reuse the structure</span><br>    <span class="hljs-keyword">if</span> ( fds[<span class="hljs-number">0</span>].revents &amp; POLLIN )<br>        fds[<span class="hljs-number">0</span>].revents = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// input event on sock1</span><br><br>    <span class="hljs-keyword">if</span> ( fds[<span class="hljs-number">1</span>].revents &amp; POLLOUT )<br>        fds[<span class="hljs-number">1</span>].revents = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// output event on sock2</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ol><li><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a><strong>功能</strong></h5><p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p><ul><li>select 会修改描述符，而 poll 不会；</li><li>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li><li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。</li><li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</li></ul></li><li><p><strong>速度</strong></p><p>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p></li><li><p><strong>可移植性</strong></p><p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p></li></ol><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span>；</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event * events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span></span>;<br></code></pre></td></tr></table></figure><p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I&#x2F;O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p><p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p><p>epoll 仅适用于 Linux OS。</p><p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p><p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.</span><br><span class="hljs-comment">// The function argument is ignored (it was not before, but now it is), so put your favorite number here</span><br><span class="hljs-type">int</span> pollingfd = <span class="hljs-built_in">epoll_create</span>( <span class="hljs-number">0xCAFE</span> );<br><br><span class="hljs-keyword">if</span> ( pollingfd &lt; <span class="hljs-number">0</span> )<br> <span class="hljs-comment">// report error</span><br><br><span class="hljs-comment">// Initialize the epoll structure in case more members are added in future</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> ev = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-comment">// Associate the connection class instance with the event. You can associate anything</span><br><span class="hljs-comment">// you want, epoll does not use this information. We store a connection class pointer, pConnection1</span><br>ev.data.ptr = pConnection1;<br><br><span class="hljs-comment">// Monitor for input, and do not automatically rearm the descriptor after the event</span><br>ev.events = EPOLLIN | EPOLLONESHOT;<br><span class="hljs-comment">// Add the descriptor into the monitoring list. We can do it even if another thread is</span><br><span class="hljs-comment">// waiting in epoll_wait - the descriptor will be properly added</span><br><span class="hljs-keyword">if</span> ( <span class="hljs-built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;<span class="hljs-built_in">getSocket</span>(), &amp;ev ) != <span class="hljs-number">0</span> )<br>    <span class="hljs-comment">// report error</span><br><br><span class="hljs-comment">// Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> pevents[ <span class="hljs-number">20</span> ];<br><br><span class="hljs-comment">// Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event array</span><br><span class="hljs-type">int</span> ready = <span class="hljs-built_in">epoll_wait</span>( pollingfd, pevents, <span class="hljs-number">20</span>, <span class="hljs-number">10000</span> );<br><span class="hljs-comment">// Check if epoll actually succeed</span><br><span class="hljs-keyword">if</span> ( ret == <span class="hljs-number">-1</span> )<br>    <span class="hljs-comment">// report error and abort</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( ret == <span class="hljs-number">0</span> )<br>    <span class="hljs-comment">// timeout; no event detected</span><br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-comment">// Check if any events detected</span><br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ready; i++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> ( pevents[i].events &amp; EPOLLIN )<br>        &#123;<br>            <span class="hljs-comment">// Get back our connection pointer</span><br>            Connection * c = (Connection*) pevents[i].data.ptr;<br>            c-&gt;<span class="hljs-built_in">handleReadEvent</span>();<br>         &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p><ol><li><p><strong>LT 模式</strong></p><p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p></li><li><p><strong>ET 模式</strong></p><p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p><p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p></li></ol><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p><ol><li><p><strong>select 应用场景</strong></p><p>select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</p><p>select 可移植性更好，几乎被所有主流平台所支持。</p></li><li><p><strong>poll 应用场景</strong></p><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p></li><li><p><strong>epoll 应用场景</strong></p><p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</p><p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p><p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络基础</tag>
      
      <tag>五层协议</tag>
      
      <tag>HTTP/HTTPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象思想</title>
    <link href="/2022/07/10/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/"/>
    <url>/2022/07/10/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h1><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md#%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB-generalization">资料来源</a></p><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><p>优点：</p><ul><li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li><li>减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能</li><li>提高软件的可重用性</li><li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li></ul><p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p><p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> gender;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getGender</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">gender</span> <span class="hljs-operator">=</span>= <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;man&quot;</span> : <span class="hljs-string">&quot;woman&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">18</span> &lt;= age &amp;&amp; age &lt;= <span class="hljs-number">50</span>) &#123;<br>            System.out.println(name + <span class="hljs-string">&quot; is working very hard!&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(name + <span class="hljs-string">&quot; can&#x27;t work any more!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承实现了 <strong><a href="https://baike.baidu.com/item/Is-a/15813994?fr=aladdin">IS-A</a></strong> 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><p>继承应该遵循**<a href="http://c.biancheng.net/view/1324.html">里氏替换原则</a>**，子类对象必须能够替换掉所有父类对象。</p><p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 <strong>向上转型</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br></code></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态分为<strong>编译时多态</strong>和<strong>运行时多态</strong>：</p><ul><li>编译时多态主要指方法的**<a href="https://baike.baidu.com/item/overload/5090058?fromtitle=%E9%87%8D%E8%BD%BD&fromid=2282654&fr=aladdin">重载</a>**</li><li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>运行时多态有三个条件：</p><ul><li>继承</li><li>覆盖（重写）</li><li>向上转型</li></ul><p>下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Instrument</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Instument is playing...&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wind</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Instrument</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Wind is playing...&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Percussion</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Instrument</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Percussion is playing...&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Music</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Instrument&gt; instruments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        instruments.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Wind</span>());<br>        instruments.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Percussion</span>());<br>        <span class="hljs-keyword">for</span>(Instrument instrument : instruments) &#123;<br>            instrument.play();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">Wind</span></span> is playing...<br><span class="hljs-function"><span class="hljs-title">Percussion</span></span> is playing...<br></code></pre></td></tr></table></figure><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>类图显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。它既用于应用程序的系统分类的一般概念建模，也用于详细建模，将模型转换成编程代码。类图也可用于数据建模。</p><ul><li><p><strong>泛化关系 (Generalization)</strong></p><p>用来描述继承关系，在 Java 中使用 extends 关键字。</p></li><li><p><strong>实现关系 (Realization)</strong></p><p>用来实现一个接口，在 Java 中使用 implements 关键字。</p></li><li><p><strong>聚合关系 (Aggregation)</strong></p><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p></li><li><p><strong>组合关系 (Composition)</strong></p><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p></li><li><p><strong>关联关系 (Association)</strong></p><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p></li><li><p><strong>依赖关系 (Dependency)</strong></p><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</p><ul><li>A 类是 B 类方法的局部变量；</li><li>A 类是 B 类方法的参数；</li><li>A 类向 B 类发送消息，从而影响 B 类发生变化。</li></ul></li></ul><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="S-O-L-I-D"><a href="#S-O-L-I-D" class="headerlink" title="S.O.L.I.D"></a>S.O.L.I.D</h3><table><thead><tr><th>简写</th><th>全拼</th><th>中文翻译</th></tr></thead><tbody><tr><td>SRP</td><td>The Single Responsibility Principle</td><td>单一责任原则</td></tr><tr><td>OCP</td><td>The Open Closed Principle</td><td>开放封闭原则</td></tr><tr><td>LSP</td><td>The Liskov Substitution Principle</td><td>里氏替换原则</td></tr><tr><td>ISP</td><td>The Interface Segregation Principle</td><td>接口分离原则</td></tr><tr><td>DIP</td><td>The Dependency Inversion Principle</td><td>依赖倒置原则</td></tr></tbody></table><h4 id="1-单一责任原则"><a href="#1-单一责任原则" class="headerlink" title="1. 单一责任原则"></a>1. 单一责任原则</h4><blockquote><p>修改一个类的原因应该只有一个。</p></blockquote><p>换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。</p><h4 id="2-开放封闭原则"><a href="#2-开放封闭原则" class="headerlink" title="2. 开放封闭原则"></a>2. 开放封闭原则</h4><blockquote><p>类应该对扩展开放，对修改关闭。</p></blockquote><p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。</p><p>符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p><h4 id="3-里氏替换原则"><a href="#3-里氏替换原则" class="headerlink" title="3. 里氏替换原则"></a>3. 里氏替换原则</h4><blockquote><p>子类对象必须能够替换掉所有父类对象。</p></blockquote><p>继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。</p><p>如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p><h4 id="4-接口分离原则"><a href="#4-接口分离原则" class="headerlink" title="4. 接口分离原则"></a>4. 接口分离原则</h4><blockquote><p>不应该强迫客户依赖于它们不用的方法。</p></blockquote><p>因此使用多个专门的接口比使用单一的总接口要好。</p><h4 id="5-依赖倒置原则"><a href="#5-依赖倒置原则" class="headerlink" title="5. 依赖倒置原则"></a>5. 依赖倒置原则</h4><blockquote><p>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；<br>抽象不应该依赖于细节，细节应该依赖于抽象。</p></blockquote><p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</p><p>依赖于抽象意味着：</p><ul><li>任何变量都不应该持有一个指向具体类的指针或者引用；</li><li>任何类都不应该从具体类派生；</li><li>任何方法都不应该覆写它的任何基类中的已经实现的方法。</li></ul><h3 id="其他常见原则"><a href="#其他常见原则" class="headerlink" title="其他常见原则"></a>其他常见原则</h3><p>除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。</p><table><thead><tr><th>简写</th><th>全拼</th><th>中文翻译</th></tr></thead><tbody><tr><td>LOD</td><td>The Law of Demeter</td><td>迪米特法则</td></tr><tr><td>CRP</td><td>The Composite Reuse Principle</td><td>合成复用原则</td></tr><tr><td>CCP</td><td>The Common Closure Principle</td><td>共同封闭原则</td></tr><tr><td>SAP</td><td>The Stable Abstractions Principle</td><td>稳定抽象原则</td></tr><tr><td>SDP</td><td>The Stable Dependencies Principle</td><td>稳定依赖原则</td></tr></tbody></table><h4 id="1-迪米特法则"><a href="#1-迪米特法则" class="headerlink" title="1. 迪米特法则"></a>1. 迪米特法则</h4><p>迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。</p><h4 id="2-合成复用原则"><a href="#2-合成复用原则" class="headerlink" title="2. 合成复用原则"></a>2. 合成复用原则</h4><p>尽量使用对象组合，而不是通过继承来达到复用的目的。</p><h4 id="3-共同封闭原则"><a href="#3-共同封闭原则" class="headerlink" title="3. 共同封闭原则"></a>3. 共同封闭原则</h4><p>一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。</p><h4 id="4-稳定抽象原则"><a href="#4-稳定抽象原则" class="headerlink" title="4. 稳定抽象原则"></a>4. 稳定抽象原则</h4><p>最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。</p><h4 id="5-稳定依赖原则"><a href="#5-稳定依赖原则" class="headerlink" title="5. 稳定依赖原则"></a>5. 稳定依赖原则</h4><p>包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。</p>]]></content>
    
    
    <categories>
      
      <category>面向对象思想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象思想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统</title>
    <link href="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h1><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%A6%82%E8%BF%B0.md#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F---%E6%A6%82%E8%BF%B0">资料来源</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>并发指在一段时间内能同时运行多个程序，并行指同一时刻能运行多个指令。</p><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p>共享指系统中的资源可以被多个并发进程共同使用，分为互斥共享、同时共享。</p><ul><li>互斥共享：其资源被称为临界资源，在同一时刻只允许一个进程访问，需要用同步机制来是想互斥访问。</li></ul><h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><p>将一个物理实体转换为多个逻辑实体</p><p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术</p><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>计算机多线程的异步处理：与同步处理相对，异步处理不用阻塞当前线程来等待处理完成，而是允许后续操作，直至其它线程将处理完成，并回调通知此线程。</p><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><ul><li>进程管理</li><li>内存管理</li><li>文件管理</li><li>设备管理</li></ul><h3 id="宏内核和微内核"><a href="#宏内核和微内核" class="headerlink" title="宏内核和微内核"></a>宏内核和微内核</h3><ul><li><strong>宏内核</strong>：宏内核是将操作系统功能作为一个紧密结合的整体放到内核。由于各模块共享信息，因此有<strong>很高的性能</strong>。</li><li><strong>微内核</strong>：由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而<strong>降低内核的复杂性</strong>。移出的部分根据分层的原则划分成若干服务，相互独立。因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的<strong>性能损失</strong>。</li></ul><h3 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h3><ul><li>外中断</li><li>异常</li><li>陷入</li></ul><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><ul><li><strong>进程</strong>：资源分配的基本单位。</li><li><strong>线程</strong>：线程是独立调度的基本单位。一个<strong>进程</strong>可以有多个<strong>线程</strong>，他们共享进程资源。</li><li><strong>区别</strong>：<ol><li>拥有资源：进程是资源分配的基本单位，但是<strong>线程不拥有资源</strong>，线程可以访问隶属进程的资源。</li><li>调度：线程是独立调度的基本单位，在同一进程中，<strong>线程的切换不会引起进程切换</strong>，从一个进程的线程切换到另一个进程的线程，<strong>会引起进程切换</strong>。</li><li>系统开销：创建或撤销<strong>进程</strong>时，系统都要为之分配或回收资源，所付出的开销远大于创建或撤销<strong>线程</strong>时的开销。</li><li>通信方面：<strong>线程</strong>间可以通过直接读写同一进程中的数据进行通信，但是<strong>进程</strong>通信需要借助IPC（进程间通信）。</li></ol></li></ul><h3 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h3><ul><li>就绪状态：等待被调度</li><li>运行状态</li><li>阻塞状态：等待资源</li></ul><p>注意以下内容</p><ul><li><strong>只有就绪态和运行态可以相互转换</strong>，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是<strong>缺少需要的资源</strong>从而由运行状态转换而来，但是该资源<strong>不包括 CPU 时间</strong>，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）</p><ul><li><strong>先来先服务 first-come first-serve (FCFS)<strong>：非抢占式的调度算法，按照</strong>请求的顺序</strong>进行调度。利于长作业不利于短作业（等待长作业执行完毕会导致作业等待时间过长）。</li><li><strong>短作业优先 shortest job first (SJF)<strong>：非抢占式的调度算法，按</strong>估计运行时间最短的顺序</strong>进行调度。（长作业一直处于等待短作业执行完毕的状态，因此如果等待期间一直有短作业到来，那么长作业将永远得不到调度）</li><li><strong>最短剩余时间优先 shortest remaining time next (SRTN)<strong>：最短作业优先的抢占式版本，按</strong>剩余运行时间的顺序</strong>进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</li></ul><h4 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h4><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><ul><li><p><strong>时间片轮转</strong>：将所有就绪进程按 <strong>FCFS</strong> 的原则排成一个队列，每次调度时，把 CPU 时间<strong>分配给队首进程</strong>，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它<strong>送往就绪队列的末尾</strong>，同时继续把 CPU 时间<strong>分配给队首的进程</strong>。</p><p>时间片轮转算法的效率和时间片的大小有很大关系：</p><ul><li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致<strong>进程切换得太频繁</strong>，在进程切换上就会花过多时间。</li><li>而如果时间片过长，那么<strong>实时性</strong>就不能得到保证。</li></ul></li><li><p><strong>优先级调度</strong>：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以<strong>随着时间的推移增加等待进程的优先级</strong>。</p></li><li><p><strong>多级反馈队列</strong>：一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了<strong>多个队列</strong>，每个队列<strong>时间片大小都不同</strong>，例如 1,2,4,8,..。进程在<strong>第一个队列</strong>没执行完，就会被移到<strong>下一个队列</strong>。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，<strong>最上面的优先权最高</strong>。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p></li></ul><h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><p>实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>对临界资源（一次仅允许一个进程使用的资源）进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><h4 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h4><ul><li><strong>同步</strong>：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li><strong>互斥</strong>：多个进程在同一时刻只有一个进程能够进入临界区。</li></ul><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量    *"></a>信号量    *</h4><p>是在<strong>多线程环境</strong>下使用的一种设施，是可以用来保证两个或多个关键代码段不被<strong>并发</strong>调用。</p><p>信号量是一个整型变量，可对其执行down和up操作，也就是常见的P和V操作。</p><ul><li>down：如果信号量大于0，执行-1操作；如果信号量等于0，进程睡眠，等待信号量大于0。</li><li>up：对信号量执行+1操作，唤醒睡眠的进程让其完成down操作。</li></ul><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁</p><h4 id="管程"><a href="#管程" class="headerlink" title="管程    *"></a>管程    *</h4><p>在功能上和信号量及PV操作类似，属于一种进程同步互斥工具，但具有与信号量及PV操作不同的属性。</p><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p><p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p><p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题    *"></a>哲学家进餐问题    *</h4><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><p>下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p><p>为了防止死锁的发生，可以设置两个条件：</p><ul><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ul><h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题    *"></a>读者-写者问题    *</h4><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程同步与进程通信很容易混淆，它们的区别在于：</p><ul><li><strong>进程同步</strong>：控制多个进程按一定顺序执行</li><li><strong>进程通信</strong>：进程间传输信息</li></ul><p>为了达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><h4 id="管道"><a href="#管道" class="headerlink" title="管道    *"></a>管道    *</h4><p>管道时通过调用pipe函数创建的，fd[0]用于读，fd[1]用于写。</p><p>它具有以下限制：</p><ul><li>只支持半双工通信（单项交替传输）</li><li>只能在父子进程或者兄弟进程中使用。</li></ul><h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO    *"></a>FIFO    *</h4><p>也成为<strong>命名管道</strong>，去除了管道只能在父子进程中使用的限制。</p><p>FIFO常用于客户-服务器应用程序中，FIFO用作汇聚点，在客户进程和服务器进程之间传递数据。</p><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列    *"></a>消息队列    *</h4><p>相比于FIFO，消息队列具有以下优点：</p><ul><li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li><li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li></ul><h4 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h4><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p><h4 id="共享储存"><a href="#共享储存" class="headerlink" title="共享储存    *"></a>共享储存    *</h4><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p><h4 id="套接字"><a href="#套接字" class="headerlink" title="套接字    *"></a>套接字    *</h4><p>与其他通信机制不同的是，它可用于不同机器间的进程通信。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ul><li><strong>互斥</strong>：每个资源要么已经分配给了一个进程，要么就是可用的。</li><li><strong>占有和等待</strong>：已经得到了某个资源的进程可以再请求新的资源。</li><li><strong>不可抢占</strong>：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li><li><strong>环路等待</strong>：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li></ul><h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><p>主要有以下四种方法：</p><ul><li>鸵鸟策略</li><li>死锁检测与死锁恢复</li><li>死锁预防</li><li>死锁避免</li></ul><h4 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h4><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为<strong>解决死锁问题的代价很高</strong>，因此鸵鸟策略这种不采取任务措施的方案会<strong>获得更高的性能</strong>。</p><p><strong>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</strong></p><p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是<strong>忽略</strong>它。</p><h4 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复    *"></a>死锁检测与死锁恢复    *</h4><p>不是图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><ol><li><p><strong>每种类型一个资源的死锁检测</strong></p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220620171309516-165586531113612.png" alt="image-20220620171309516" style="zoom:67%;"><p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p><p>图 a 可以抽取出环，如图 b，它<strong>满足了环路等待条件</strong>，因此会发生死锁。</p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p></li><li><p><strong>每种类型多个资源的死锁检测</strong></p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220621093312175-165586531113613.png" alt="image-20220621093312175" style="zoom:67%;"><p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p><ul><li>E 向量：资源总量</li><li>A 向量：资源剩余量</li><li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li><li>R 矩阵：每个进程请求的资源数量</li></ul><p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A &#x3D; (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A &#x3D; (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</p><p>算法总结如下：</p><p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p><ol><li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li><li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li><li>如果没有这样一个进程，算法终止。</li></ol></li><li><p><strong>死锁恢复</strong></p><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul></li></ol><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>在程序运行之前预防发生死锁</p><ol><li><p><strong>破坏互斥条件</strong></p><p>例如假脱机打印机技术运行若干个进程同时输出，唯一真正请求物理打印机的进程是打印机<strong>守护进程</strong>（一类在后台运行的特殊进程，用于执行特定的系统任务）。</p></li><li><p><strong>破坏占有和等待条件</strong></p><p>一种实现方式是规定所有进程给在开始执行前请求所需要的全部资源。</p></li><li><p><strong>破坏不可抢占条件</strong></p></li><li><p><strong>破坏坏路等待</strong></p><p>给资源同一编号，进程只能按编号顺序来请求资源。</p></li></ol><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免    *"></a>死锁避免    *</h3><p>在程序运行时避免发生死锁。</p><ol><li><p><strong>安全状态</strong></p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220621095511066-165586531113614.png" alt="image-20220621095511066" style="zoom:67%;"><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的<strong>最大</strong>需求，也仍然存在某种调度次序能够使得<strong>每一个进程</strong>运行完毕，则称该状态是安全的。</p><p>安全状态的检测与死锁的检测类似，因为安全状态<strong>必须</strong>要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p></li><li><p><strong>单个资源的银行家算法</strong></p><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220621095957138-165586531113615.png" alt="image-20220621095957138" style="zoom:67%;"><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p></li><li><p><strong>多个资源的银行家算法</strong></p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220621100310094-165586531113616.png" alt="image-20220621100310094" style="zoom:67%;"><p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A&#x3D;(1020)，表示 4 个资源分别还剩下 1&#x2F;0&#x2F;2&#x2F;0。</p><p>检查一个状态是否安全的算法如下：</p><ul><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ul><p>如果一个状态不是安全的，需要拒绝进入这个状态。</p></li></ol><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存    *"></a>虚拟内存    *</h3><p>虚拟内存的目的是为了让<strong>物理内存</strong>扩充成更大的<strong>逻辑内存</strong>，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p><h3 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射    *"></a>分页系统地址映射    *</h3><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p><p>一个虚拟地址分成两个部分，一部分存储<strong>页面号</strong>，一部分存储<strong>偏移量</strong>。</p><p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220621111131728-165586531113617.png" alt="image-20220621111131728" style="zoom:67%;"><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘兑换去中来腾出空间。</p><p>页面置换算法和缓存淘汰策略类似，可以将内存堪称磁盘的缓存，在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h4 id="最优替换算法（OPT）"><a href="#最优替换算法（OPT）" class="headerlink" title="最优替换算法（OPT）"></a>最优替换算法（OPT）</h4><p>所选择的被换出的页面僵尸最长时间内不再被访问，通常可以保证获得最低的却也略。</p><p>这是一种理论上的算法，因为无法知道一个页面多长时间不再访问。</p><p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">7</span>，<span class="hljs-number">0</span>，<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">0</span>，<span class="hljs-number">3</span>，<span class="hljs-number">0</span>，<span class="hljs-number">4</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">0</span>，<span class="hljs-number">3</span>，<span class="hljs-number">2</span>，<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">0</span>，<span class="hljs-number">1</span>，<span class="hljs-number">7</span>，<span class="hljs-number">0</span>，<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>开始运行时，先将7,0,1三个页面装入内存。当进程要访问页面2时，产生缺页中断，会将页面7换出，因为页面7再次被访问的时间最长。</p><h4 id="最近最久未使用（LRU）"><a href="#最近最久未使用（LRU）" class="headerlink" title="最近最久未使用（LRU）"></a>最近最久未使用（LRU）</h4><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU将最近最久未使用的页面换出。</p><p>为了实现LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这页面移到链表表头。这样就能保证链表表尾的页面时最近最久未访问的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的LRU代价很高。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220621113011645-165586531113618.png" alt="image-20220621113011645" style="zoom:67%;"><h4 id="最近未使用（NRU）"><a href="#最近未使用（NRU）" class="headerlink" title="最近未使用（NRU）"></a>最近未使用（NRU）</h4><p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R&#x3D;1，当页面被修改时设置 M&#x3D;1。其中 R 位会定时被清零。可以将页面分成以下四类：</p><ul><li>R&#x3D;0，M&#x3D;0</li><li>R&#x3D;0，M&#x3D;1</li><li>R&#x3D;1，M&#x3D;0</li><li>R&#x3D;1，M&#x3D;1</li></ul><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p><p>NRU 优先换出已经被修改的脏页面（R&#x3D;0，M&#x3D;1），而不是被频繁使用的干净页面（R&#x3D;1，M&#x3D;0）。</p><h4 id="先进先出（FIFO）"><a href="#先进先出（FIFO）" class="headerlink" title="先进先出（FIFO）"></a>先进先出（FIFO）</h4><p>选择换出的页面是最先进入的页面。</p><p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p><h4 id="第二次机会算法"><a href="#第二次机会算法" class="headerlink" title="第二次机会算法"></a>第二次机会算法</h4><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p><p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索</p><h4 id="时钟（Clock）"><a href="#时钟（Clock）" class="headerlink" title="时钟（Clock）"></a>时钟（Clock）</h4><p>第二次机会算法需要在链表中移动页面，降低了效率。始终算法使用环形链表将页面连接起来，再使用一个指针指向自老的页面。</p><h3 id="分段"><a href="#分段" class="headerlink" title="分段    *"></a>分段    *</h3><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p><p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220622093752961-165586531113619.png" alt="image-20220622093752961" style="zoom:67%;"><p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p><h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式    *"></a>段页式    *</h3><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p><h3 id="分页与分段的比较"><a href="#分页与分段的比较" class="headerlink" title="分页与分段的比较"></a>分页与分段的比较</h3><ul><li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li><li>地址空间的维度：分页是一维地址空间，分段是二维的。</li><li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li><li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><ul><li><p>盘面（Platter）：一个磁盘有多个盘面；</p></li><li><p>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</p></li><li><p>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</p></li><li><p>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</p></li><li><p>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</p></li><li><p>主轴（Spindle）：使整个盘面转动。</p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220622101834140-165586531113620.png" alt="image-20220622101834140" style="zoom:67%;"></li></ul><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>读写一个磁盘块的时间的影响因素有：</p><ul><li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li><li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li><li>实际的数据传输时间</li></ul><p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p><h4 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h4><p>按照磁盘请求的顺序进行调度。</p><p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p><h4 id="最短寻道时间优先（SSTF）"><a href="#最短寻道时间优先（SSTF）" class="headerlink" title="最短寻道时间优先（SSTF）"></a>最短寻道时间优先（SSTF）</h4><p>优先调度与当前磁头所在磁道距离最近的磁道。</p><p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p><h4 id="电梯算法（SCAN）"><a href="#电梯算法（SCAN）" class="headerlink" title="电梯算法（SCAN）"></a>电梯算法（SCAN）</h4><p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p><p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p><p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="编译系统"><a href="#编译系统" class="headerlink" title="编译系统"></a>编译系统</h3><p>以下是一个 hello.c 程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, world\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">gcc -o hello hello.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p>这个过程大致如下：</p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220622102350707-165586531113621.png" alt="image-20220622102350707" style="zoom:67%;"><ul><li>预处理阶段：处理以 # 开头的预处理命令；</li><li>编译阶段：翻译成汇编文件；</li><li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li><li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li></ul><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p><ul><li><p>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</p></li><li><p>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</p><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220622102607564-165586531113622.png" alt="image-20220622102607564" style="zoom:67%;"></li></ul><h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件    *"></a>目标文件    *</h3><ul><li>可执行目标文件：可以直接在内存中执行；</li><li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li><li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li></ul><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>静态库有以下两个问题：</p><ul><li>当静态库更新时那么整个程序都要重新进行链接；</li><li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li></ul><p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p><ul><li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li><li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li></ul><img src="/2022/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220622103045693.png" alt="image-20220622103045693" style="zoom:67%;">]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进程</tag>
      
      <tag>并发</tag>
      
      <tag>异步</tag>
      
      <tag>死锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WEB安全</title>
    <link href="/2022/05/19/WEB%E5%AE%89%E5%85%A8/"/>
    <url>/2022/05/19/WEB%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="WEB安全"><a href="#WEB安全" class="headerlink" title="WEB安全"></a>WEB安全</h1><h2 id="常用漏洞"><a href="#常用漏洞" class="headerlink" title="常用漏洞"></a>常用漏洞</h2><h3 id="CSRF漏洞"><a href="#CSRF漏洞" class="headerlink" title="CSRF漏洞"></a>CSRF漏洞</h3><p><strong>跨站请求伪造</strong>，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</p><p>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</p><p>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</p><p>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</p><p>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下<strong>携带Cookie信息</strong>，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。</p><h4 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h4><ul><li><strong>token谁机制防御</strong>：在请求地址中添加token并验证。要抵御CSRF，关键在于在请求中放入和黑客所不能伪造的信息，并且该信息<strong>不存在于cookie</strong>中。可以在http请求中以参数的形式加入一个<strong>随机产生的token</strong>，并且在服务器端建立一个拦截器来验证这个token值，如果请求中没有token值或者token不正确，则可以认为可能是CSRF攻击而拒绝请求。</li><li><strong>referer值校验</strong>：增加HTTP referer的校验。http协议中，在http头部中有一个字段叫referer，它记录了该<strong>http请求的来源地址</strong>。如果referer记录的不是同一个浏览器的请求，那么久可能是攻击者伪造的恶意链接，可以根据此方法来防范CSRF攻击</li></ul><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>主要形成的原因是在世俗据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的内容拼接到sql语句中后，<strong>被当作sql语句的一部分执行</strong>。从而导致数据库受损等安全问题。即，注入产生的原因是后台服务器接收相关参数<strong>未经过过滤</strong>直接带入数据库查询。</p><h4 id="修复建议-1"><a href="#修复建议-1" class="headerlink" title="修复建议"></a>修复建议</h4><ul><li>对用户提交数据信息进行严格多次的<strong>筛选过滤</strong></li><li>用户内数据内容进行<strong>加密</strong></li><li><strong>代码层</strong>最佳防御sql漏洞方案：采用sql语句<strong>预编译和绑定变量</strong></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h5><p>寻找注入点的本质是找一个需要后台处理后提交给数据库的点，所有的输入<strong>只要和数据库进行交互的</strong>，都可能触发sql注入。</p><p>注入点一般分为三大类</p><ul><li><strong>get</strong>参数触发</li><li><strong>post</strong>参数触发</li><li><strong>cookie</strong>触发</li></ul><p>最简单的方法，引入单引号判断是否存在注入点</p><h5 id="判断是否存在注入"><a href="#判断是否存在注入" class="headerlink" title="判断是否存在注入"></a>判断是否存在注入</h5><p>注入点可否利用与服务端代码和服务器配置息息相关，如<strong>过滤一些危险函数或者限制参数的长度</strong>等，会导致注入难度提升甚至不可利用。</p><ul><li><p><strong>有回显</strong>的注入判断：</p><ul><li>输入单引号，若显示错误则存在sql注入。</li><li>利用逻辑符号判断，参数后加<code>and 1=1</code>或<code>and 1=2</code>，若and 1&#x3D;1页面正常and 1&#x3D;2页面错误，则存在sql注入。同理使用or也可判断。</li></ul></li><li><p><strong>无回显</strong>的注入判断：通过<strong>sleep()<strong>进行判断，若页面返回</strong>符合设置的延迟</strong>，则存在sql注入。（不同数据库有不同的演示函数，需要结合具体情况来使用）</p></li></ul><h5 id="注入类型判断"><a href="#注入类型判断" class="headerlink" title="注入类型判断"></a>注入类型判断</h5><ul><li><p>数字型注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs mysql">select * from table where id=3;<br></code></pre></td></tr></table></figure></li><li><p>字符型注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from table where name=&#x27;admin&#x27;;<br></code></pre></td></tr></table></figure></li></ul><p>需要添加引号去闭合参数的是字符型注入，不需要添加引号的是数字型注入。</p><h5 id="select-1-2-3"><a href="#select-1-2-3" class="headerlink" title="select 1,2,3;"></a>select 1,2,3;</h5><p>如某些网站的参数传递执行的查询有3个字段，但并<strong>不是所有的字段查询结果都会返回</strong>前端的，所以我们需要知道这3个字段中有哪些字段会回显，这个过程相当于找到<strong>数据库与前端显示的通道</strong>。</p><p>执行语句后，通过显示内容就知道哪个数字是这个通道，就可以将这个数字改成问们想查询的内容，结果将会回显到前端。</p><p>如指定数据库的表，即<code>select 1,2,3 from tablename;</code>,返回结果输入数值将替换原来的字段，行数与原数据库表的结构保持一致，即表中有多少行就返回多少行。</p><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h4 id="sql注入万能密码原理"><a href="#sql注入万能密码原理" class="headerlink" title="sql注入万能密码原理"></a>sql注入万能密码原理</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27; or 1=1#</span><br></code></pre></td></tr></table></figure><p>用户登陆界面sql语句一般为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">where</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;user&#x27;</span> <span class="hljs-keyword">and</span> password<span class="hljs-operator">=</span>&quot;pass&quot;;<br></code></pre></td></tr></table></figure><p>当输入正确的账号密码就会返回真值。</p><p>在sql语句中<code>#</code>后的内容将会被省略，输入万能密码后sql语句变为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">where</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span># <span class="hljs-keyword">and</span> password<span class="hljs-operator">=</span>&quot;pass&quot;;<br></code></pre></td></tr></table></figure><p><code>#</code>后的内容被省略，且语句返回为真。</p>]]></content>
    
    
    <categories>
      
      <category>安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>后端笔记</title>
    <link href="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>学习路线图</strong></p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/backend-map-16529596795671.png" alt="backend-map" style="zoom: 50%;"><h1 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h1><h2 id="网络是如何工作的"><a href="#网络是如何工作的" class="headerlink" title="网络是如何工作的"></a>网络是如何工作的</h2><h3 id="互联网的解释"><a href="#互联网的解释" class="headerlink" title="互联网的解释"></a>互联网的解释</h3><h4 id="TCP-x2F-IP协议"><a href="#TCP-x2F-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h4><p>​        传输控制协议&#x2F;网际协议（也叫做网络通讯协议），是指能够在不同网络间实现信息传输的协议簇。它是在网络的使用中的最基本的通信协议。TCP&#x2F;IP传输协议对互联网中各部分进行通信的标准和方法进行了规定。并且，TCP&#x2F;IP传输协议是保证网络数据信息及时、完整传输的两个重要的协议。TCP&#x2F;IP传输协议是严格来说是一个四层的体系结构，应用层、传输层、网络层和数据链路层都包含其中。</p><p>​        TCP&#x2F;IP协议是Internet最基本的协议,其中应用层的主要协议有<a href="https://baike.baidu.com/item/Telnet/810597">Telnet</a>、<a href="https://baike.baidu.com/item/FTP/13839">FTP</a>、<a href="https://baike.baidu.com/item/SMTP/175887">SMTP</a>等，是用来接收来自传输层的数据或者按不同应用要求与方式将数据传输至传输层；传输层的主要协议有<a href="https://baike.baidu.com/item/UDP/571511">UDP</a>、TCP，是使用者使用平台和计算机信息网内部数据结合的通道，可以实现数据传输与数据共享；网络层的主要协议有ICMP、IP、IGMP，主要负责网络中数据包的传送等；而网络访问层，也叫网络接口层或数据链路层，主要协议有ARP、<a href="https://baike.baidu.com/item/RARP/610685">RARP</a>，主要功能是提供链路管理错误检测、对不同通信媒介有关信息细节问题进行有效处理等。</p><p>​        TCP&#x2F;IP协议不仅仅值的是TCP和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇，只是因为在该协议中TCP协议和IP协议最具代表性，所以被称为TCP&#x2F;IP协议。</p><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>​        互网络协议地址，又称网际协议地址。</p><p>​        IP地址是IP协议协议&#x2F;131947)提供的一种统一的<a href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F/53569124">地址格式</a>，它为互联网上的每一个网络和每一台<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机</a>分配一个<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/3283849">逻辑地址</a>，以此来屏蔽<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/2901583">物理地址</a>的差异。</p><ul><li><strong>IPv6</strong></li></ul><p>​                当前的互联网标准（IPv4）金允许大约40亿个ip地址，在2019年        11月25日已全部分配完毕。早在1990年IPv6的新标准就以产生，IPv6        允许的唯一地址，确切的数字是39位数，确保世界永远不会再用完。</p><h4 id="W3C-万维网联盟"><a href="#W3C-万维网联盟" class="headerlink" title="W3C(万维网联盟)"></a>W3C(万维网联盟)</h4><p>​        web技术领域最具权威和影响力的国际中立性技术标准机构。W3C发布了多项影响深远的web技术标准及实施指南，如广为业界采用的超文本标记语言HTML（标准通用标记语言下的一个应用），可扩展标记语言XML（标准通用标记语言下的一个子集）等等，有效促进了web技术的互相兼容，对互联网技术的发展和应用起到了基础性和根本性的支撑作用。</p><h4 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h4><p>​        Secure Sockets Layer的缩写，是一系列加密技术，允许 Web 用户保护他们通过 Internet 传输的信息的隐私。</p><p>​        例如谷歌浏览器url地址旁有个锁的图标，该锁应该表明第三方将无法读取您发送或接收的任何信息。在幕后，SSL 通过将您的数据转换为只有接收者知道如何破译的编码消息来实现这一点。如果恶意方正在收听对话，它只会看到看似随机的字符串，而不是您私人信息。</p><h4 id="域名系统（DNS）"><a href="#域名系统（DNS）" class="headerlink" title="域名系统（DNS）"></a>域名系统（DNS）</h4><p>​        它作为将域名和ip地址相互映射的一个分布式数据库，能够是人们更方便地访问互联网。</p><ul><li><p>通用顶级域和国家代码顶级域</p><p>通用顶级域（gTLD），例如.com、.edu、.org、.gov等</p><p>国家代码顶级域（ccTLD）世界上每个国家都有自己的2字母代码。例如，.us、.uk、.cn、.io、.tv</p></li></ul><h3 id="互联网如何运作"><a href="#互联网如何运作" class="headerlink" title="互联网如何运作"></a>互联网如何运作</h3><h4 id="从互联网地址开始"><a href="#从互联网地址开始" class="headerlink" title="从互联网地址开始"></a>从互联网地址开始</h4><p>​        连接到Internet的每台计算机都必须有一个唯一的地址。</p><h4 id="协议栈和数据包"><a href="#协议栈和数据包" class="headerlink" title="协议栈和数据包"></a>协议栈和数据包</h4><p>​        两台计算机想实现互相通信，必须先通过将计算机连接到Internet的人格类型的线路来传输信息。因此，必须将消息从字母文本翻译成电子信号，通过 Internet 传输，然后再翻译回字母文本。该部分<strong>通过使用协议栈</strong>实现 。它通常内置于计算机的操作系统中。由于使用了两种主要的通信协议，因此 Internet 上使用的协议栈被称为 TCP&#x2F;IP 协议栈。</p><p>TCP&#x2F;IP 堆栈如下：</p><table><thead><tr><th>协议层</th><th>注释</th></tr></thead><tbody><tr><td>应用协议层</td><td>特定于应用程序的协议，例如 WWW、电子邮件、FTP 等。</td></tr><tr><td>传输控制协议层</td><td>TCP 使用端口号将数据包定向到计算机上的特定应用程序。</td></tr><tr><td>互联网协议层</td><td>IP 使用 IP 地址将数据包定向到特定计算机。</td></tr><tr><td>硬件层</td><td>将二进制数据包数据转换为网络信号并返回。 （例如以太网网卡、电话线调制解调器等）</td></tr></tbody></table><p>从ip地址为1.2.3.4的计算机到IP地址为5.6.7.8的计算机之间的通信会发生以下过程：</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327103512299-16529596795682.png" alt="image-20220327103512299" style="zoom:50%;"><ol><li><p>该消息将从您计算机上协议堆栈的顶部开始，并向下工作。</p></li><li><p>如果要发送的消息很长，则消息通过的每个堆栈层都可能将消息分解成更小的数据块。这是因为通过 Internet（和大多数计算机网络）发送的数据是以可管理的块的形式发送的。在 Internet 上，这些数据块称为<strong>数据包</strong>。</p></li><li><p>数据包将通过应用层并继续到 TCP 层。每个数据包都分配有一个<strong>端口号</strong>。但足以说明许多程序可能正在使用 TCP&#x2F;IP 堆栈并发送消息。我们需要知道目标计算机上的哪个程序需要接收消息，因为它将监听特定端口。</p></li><li><p>通过 TCP 层后，数据包进入 IP 层。这是每个数据包接收其目标地址 5.6.7.8 的地方。</p></li><li><p>既然我们的消息包有一个端口号和一个 IP 地址，它们就可以通过 Internet 发送了。硬件层负责将包含我们消息的字母文本的数据包转换为电子信号并通过电话线传输它们。</p></li><li><p>在电话线的另一端，您的 ISP 直接连接到 Internet。ISP<strong>路由器</strong>检查每个数据包中的目标地址并确定将其发送到何处。通常，数据包的下一站是另一个路由器。</p></li><li><p>最终，数据包到达计算机 5.6.7.8。在这里，数据包从目标计算机的 TCP&#x2F;IP 堆栈的底部开始并向上工作。</p></li><li><p>随着数据包向上通过堆栈，发送计算机的堆栈添加的所有路由数据（例如 IP 地址和端口号）都会从数据包中剥离。</p></li><li><p>当数据到达栈顶时，数据包被重新组合成原来的形式，“Hello computer 5.6.7.8！”</p></li></ol><h4 id="网络基础设施"><a href="#网络基础设施" class="headerlink" title="网络基础设施"></a>网络基础设施</h4><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327104412823-16529596795683.png" alt="image-20220327104412823" style="zoom:50%;"><p>​        ISP（网络业务提供商） 为其拨入客户维护一个调制解调器池。这由某种形式的计算机（通常是专用计算机）管理，该计算机控制从调制解调器池到主干或专线路由器的数据流。此设置可称为端口服务器，因为它“服务”访问网络。帐单和使用信息通常也在这里收集。</p><p>​        在您的数据包通过电话网络和 ISP 的本地设备后，它们被路由到 ISP 的主干网或 ISP 购买带宽的主干网。从这里开始，数据包通常会经过多个路由器和多个骨干网、专线和其他网络，直到找到它们的目的地，即地址为 5.6.7.8 的计算机。</p><h4 id="互联网基础设施"><a href="#互联网基础设施" class="headerlink" title="互联网基础设施"></a>互联网基础设施</h4><p>​        互联网骨干网由许多相互连接的大型网络组成。这些大型网络被称为<strong>网络服务提供商</strong>或<strong>NSP</strong>。一些大型 NSP 是 UUNet、CerfNet、IBM、BBN Planet、SprintNet、PSINet 等。这些网络相互<strong>对</strong>等以交换数据包流量。每个 NSP 都需要连接到三个 <strong>网络接入点</strong>或<strong>NAP</strong>。在 NAP 处，数据包流量可能会从一个 NSP 的主干跳转到另一个 NSP 的主干。NSP 还在<strong>都会区交易所</strong>或<strong>MAE进行互连</strong>s。MAE 的用途与 NAP 相同，但属于私人所有。NAP 是最初的 Internet 互连点。NAP 和 MAE 都称为 Internet 交换点或<strong>IX</strong>。NSP 还将带宽出售给较小的网络，例如 ISP 和较小的带宽提供商。下图显示了这种分层基础设施。</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327110914707-16529596795684.png" alt="image-20220327110914707" style="zoom: 50%;"><h4 id="Internet路由层次结构"><a href="#Internet路由层次结构" class="headerlink" title="Internet路由层次结构"></a>Internet路由层次结构</h4><p>​        计算机不会知道任何其他计算机在哪里，并且数据包不会发送到每台计算机。用于将数据包送至目的地的信息包含在连接到Internet的每个路由器保存在路由表中。</p><p>​        <strong>路由器是分组交换机。</strong>路由器通常连接在网络之间以在它们之间路由数据包。每个路由器都知道它的子网以及它们使用的 IP 地址。路由器通常不知道它“上方”的 IP 地址。如下图，连接主干的黑匣子是路由器。顶部较大的 NSP 主干通过 NAP 连接。在它们之下是几个子网络，在它们之下是更多的子网络。底部是两个连接有计算机的局域网。</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327111620299-16529596795685.png" alt="image-20220327111620299" style="zoom:50%;"><p>​        当数据包到达路由器时，路由器会检查由始发计算机上的 IP 协议层放置在那里的 IP 地址。路由器检查它的路由表。如果找到包含 IP 地址的网络，则将数据包发送到该网络。如果未找到包含 IP 地址的网络，则路由器将在默认路由上发送数据包，通常沿着骨干层级向上到下一个路由器。希望下一个路由器知道将数据包发送到哪里。如果没有，则数据包再次向上路由，直到到达 NSP 骨干网。连接到 NSP 主干的路由器拥有最大的路由表，在这里数据包将被路由到正确的主干，在那里它将开始“向下”的旅程。</p><h4 id="域名和地址解析"><a href="#域名和地址解析" class="headerlink" title="域名和地址解析"></a>域名和地址解析</h4><p>但是，如果您不知道要连接的计算机的 IP 地址怎么办？您的网络浏览器如何知道这台计算机在 Internet 上的位置？所有这些问题的答案是<strong>域名服务</strong>或 <strong>DNS</strong>。DNS 是一个分布式数据库，用于跟踪 Internet 上的计算机名称及其对应的 IP 地址。</p><p>许多连接到 Internet 的计算机托管 DNS 数据库的一部分以及允许其他人访问它的软件。这些计算机称为 DNS 服务器。没有哪个 DNS 服务器包含整个数据库；它们只包含它的一个子集。如果 DNS 服务器不包含另一台计算机请求的域名，则 DNS 服务器会将请求计算机重定向到另一台 DNS 服务器。</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327112423815-16529596795686.png" alt="image-20220327112423815" style="zoom:50%;"><p>域名服务的结构类似于 IP 路由层次结构。请求名称解析的计算机将被重新定向“向上”层次结构，直到找到可以解析请求中的域名的 DNS 服务器。图 6 说明了层次结构的一部分。树的顶部是域根。在顶部附近可以看到一些较旧、更常见的域。没有显示的是世界各地的众多 DNS 服务器，它们构成了层次结构的其余部分。</p><p>建立 Internet 连接时（例如，对于 LAN 或 Windows 中的拨号网络），通常会在安装过程中指定一个主 DNS 服务器和一个或多个辅助 DNS 服务器。这样，任何需要域名解析的互联网应用程序都可以正常运行。例如，当您在 Web 浏览器中输入网址时，浏览器首先连接到您的主 DNS 服务器。获取您输入的域名的IP地址后，浏览器连接到目标计算机并请求您想要的网页。</p><h4 id="审视互联网协议"><a href="#审视互联网协议" class="headerlink" title="审视互联网协议"></a>审视互联网协议</h4><p>以下将描述Internet上一些重要的常用协议，顺序由高级别得到低级别</p><ul><li><p><strong>应用协议：HTTP和万维网</strong></p><p>​        Internet 上最常用的服务之一是万维网 (WWW)。使 Web 工作的应用程序协议是<strong>超文本传输协议</strong>或<strong>HTTP</strong>。HTTP 是 Web 浏览器和 Web 服务器用于通过 Internet 相互通信的协议。它是一种应用程序级协议，因为它位于协议栈中的 TCP 层之上，并被特定应用程序用来相互通信。在这种情况下，应用程序是 Web 浏览器和 Web 服务器。</p><p>​        HTTP 是一种基于无连接文本的协议。客户端（Web 浏览器）向 Web 服务器发送 Web 元素（例如网页和图像）的请求。请求由服务器处理后，客户端和服务器之间的 Internet 连接断开。必须为每个请求建立一个新连接。大多数协议都是面向连接的。这意味着相互通信的两台计算机通过 Internet 保持连接打开。然而，HTTP 没有。在客户端可以发出 HTTP 请求之前，必须与服务器建立新的连接。</p><p>当您在 Web 浏览器中键入 URL 时，会发生以下情况：</p><ol><li>如果 URL 包含域名，则浏览器首先连接到域名服务器并检索 Web 服务器的相应 IP 地址。</li><li>Web 浏览器连接到 Web 服务器并为所需网页发送 HTTP 请求（通过协议栈）。</li><li>Web 服务器接收请求并检查所需的页面。如果该页面存在，则 Web 服务器将其发送。如果服务器找不到请求的页面，它将发送 HTTP 404 错误消息。</li><li>Web 浏览器收到返回的页面并关闭连接。</li><li>然后浏览器解析页面并寻找完成网页所需的其他页面元素。这些通常包括图像、小程序等。</li><li>对于需要的每个元素，浏览器都会为每个元素向服务器建立额外的连接和 HTTP 请求。</li><li>当浏览器完成加载所有图像、小程序等时，页面将完全加载到浏览器窗口中。</li></ol></li><li><p><strong>应用协议：SMTP和电子邮件</strong></p><p>​        另一种常用的 Internet 服务是电子邮件。电子邮件使用称为<strong>简单邮件传输协议</strong>或 <strong>SMTP</strong>的应用程序级协议。SMTP 也是基于文本的协议，但与 HTTP 不同，SMTP 是面向连接的。SMTP 也比 HTTP 更复杂。SMTP 中的命令和注意事项比 HTTP 中的要多得多。</p><p>当您打开邮件客户端阅读电子邮件时，通常会发生以下情况：</p><ol><li>邮件客户端（Netscape Mail、Lotus Notes、Microsoft Outlook 等）打开到其默认邮件服务器的连接。邮件服务器的 IP 地址或域名通常在安装邮件客户端时设置。</li><li>邮件服务器将始终发送第一条消息以识别自己。</li><li>客户端将发送一个 SMTP HELO 命令，服务器将以 250 OK 消息响应该命令。</li><li>根据客户端是否正在检查邮件、发送邮件等，适当的 SMTP 命令将被发送到服务器，服务器将做出相应的响应。</li><li>此请求&#x2F;响应事务将继续进行，直到客户端发送 SMTP QUIT 命令。然后服务器将说再见并关闭连接。</li></ol><p>下面显示了 SMTP 客户端和 SMTP 服务器之间的简单“对话”。<strong>R：</strong>表示服务器（接收方）发送的消息，<strong>S：</strong>表示客户端（发送方）发送的消息。</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327114242924-16529596795687.png" alt="image-20220327114242924" style="zoom:50%;"><p>此 SMTP 事务取自 RFC 821，它指定了 SMTP。</p></li><li><p><strong>传输控制协议</strong></p><p>​        在协议栈的应用层之下是 TCP 层。当应用程序打开与 Internet 上另一台计算机的连接时，它们发送的消息（使用特定的应用程序层协议）通过堆栈向下传递到 TCP 层。<strong>TCP 负责将应用程序协议路由到目标计算机上的正确应用程序</strong>. 为此，使用端口号。端口可以被认为是每台计算机上的独立通道。例如，您可以一边浏览网页一边阅读电子邮件。这是因为这两个应用程序（Web 浏览器和邮件客户端）使用了不同的端口号。当数据包到达计算机并沿协议栈向上移动时，TCP 层会根据端口号决定哪个应用程序接收数据包。</p><p><strong>TCP 的工作原理</strong>：</p><ul><li>当 TCP 层从上面接收到应用层协议数据时，它会将其分割成可管理的“块”，然后在每个“块”中添加一个带有特定 TCP 信息的 TCP 标头。TCP 标头中包含的信息包括数据需要发送到的应用程序的端口号。</li><li>当 TCP 层从它下面的 IP 层接收到一个数据包时，TCP 层从数据包中剥离 TCP 头数据，必要时进行一些数据重构，然后使用从 TCP 获取的端口号将数据发送到正确的应用程序标题。</li></ul><p>TCP 不是文本协议。<strong>TCP 是一种面向连接的、可靠的字节流服务</strong>。面向连接意味着两个使用 TCP 的应用程序在交换数据之前必须先建立连接。TCP 是可靠的，因为对于接收到的每个数据包，都会向发送方发送确认以确认传送。TCP 还在其标头中包含一个校验和，用于对接收到的数据进行错误检查。TCP 标头如下所示：</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327114608248-16529596795688.png" alt="image-20220327114608248" style="zoom:50%;"><p>​        请注意，TCP 标头中没有 IP 地址的位置。这是因为 TCP 对 IP 地址一无所知。TCP 的工作是可靠地从应用程序到应用程序获取应用程序级数据。从计算机到计算机获取数据的任务是 IP 的工作。</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327114640038-16529596795689.png" alt="image-20220327114640038" style="zoom:50%;"></li><li><p><strong>互联网协议</strong></p><p>​        与 TCP 不同，<strong>IP 是一种不可靠的无连接协议</strong>。IP 不关心数据包是否到达目的地。IP 也不知道连接和端口号。 <strong>IP 的工作也是向其他计算机发送和路由数据包</strong>。IP 数据包是独立的实体，可能无序到达或根本没有到达。确保数据包到达并按正确顺序是 TCP 的工作。IP 与 TCP 唯一的共同点是它接收数据并将其自己的 IP 标头信息添加到 TCP 数据的方式。IP 标头如下所示：</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327114718431-165295967956810.png" alt="image-20220327114718431" style="zoom: 50%;"><p>上面我们在 IP 标头中看到了发送和接收计算机的 IP 地址。下面是一个数据包经过应用层、TCP层和IP层后的样子。应用层数据在 TCP 层进行分段，加上 TCP 包头，包继续到 IP 层，加上 IP 包头，然后包在 Internet 上传输。</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220327114739082-165295967956811.png" alt="image-20220327114739082" style="zoom: 50%;"></li></ul><h2 id="DNS以及DNS如何工作"><a href="#DNS以及DNS如何工作" class="headerlink" title="DNS以及DNS如何工作"></a>DNS以及DNS如何工作</h2><h3 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS"></a>什么是DNS</h3><p>域名系统 (DNS) 是 Internet 的电话簿，每台连接到 Internet 的设备都有一个唯一的 IP 地址。Web 浏览器通过Internet 协议 (IP)地址进行交互。DNS 将域名转换为IP 地址，因此浏览器可以加载 Internet 资源。</p><h3 id="DNS如何工作"><a href="#DNS如何工作" class="headerlink" title="DNS如何工作"></a>DNS如何工作</h3><p>DNS 解析过程涉及将主机名（例<a href="http://www.hah3.com)转换为计算机的/">www.hah3.com）转换为计算机的</a> IP 地址（例如 192.168.1.1）。对于 Web 浏览器，DNS 查找发生在“幕后”，除了初始请求外，不需要用户计算机的交互。</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220331171139223-165295967956812.png" alt="image-20220331171139223" style="zoom:67%;"><h4 id="加载网页涉及4个DNS服务器"><a href="#加载网页涉及4个DNS服务器" class="headerlink" title="加载网页涉及4个DNS服务器"></a>加载网页涉及4个DNS服务器</h4><ul><li><p><strong>DNS递归解析器</strong></p><p>又称<strong>DNS解析器</strong>，DNS 解析器是一种服务器，通过 Web 浏览器等应用程序接收来自客户端计算机的查询。DNS解析器是 DNS 查询中的第一站，DNS解析器作为客户端与 DNS 域名服务器的中间人。从 Web 客户端收到 DNS 查询后，<strong>DNS解析器</strong>将使用缓存的数据进行响应，无缓存数据则将向<strong>根域名服务器</strong>发送请求，接着向 <strong>TLD 域名服务器</strong>发送另一个请求，然后向<strong>权威性域名服务器</strong>发送最后一个请求。</p><p>在此过程中，<strong>DNS解析器</strong>将<strong>缓存</strong>从<strong>权威性域名服务器</strong>收到的信息。当一个客户端请求的域名 IP 地址是另一个客户端最近请求的 IP 地址时，解析器可绕过与域名服务器进行通信的过程，并仅从第二个客户端的缓存中为第一个客户端提供所请求的记录。</p></li><li><p><strong>根域名服务器</strong></p><p><strong>ipv4根域名服务器</strong>在全球有13台（1台主根域名服务器，12台辅根域名服务器，13种类型根服务器在全球范围内有多个副本服务器）。<strong>DNS解析器</strong>可以向根域名服务器发送搜寻请求，它们是<strong>DNS解析器</strong>搜寻DNS记录的第一站。<strong>根域名服务器</strong>根据该域的扩展名（.com、.net、.org 等），通过将<strong>DNS解析器</strong>定向到 <strong>TLD 域名服务器</strong>进行响应。</p></li><li><p><strong>TLD域名服务器</strong></p><p><strong>TLD 域名服务器</strong>维护共享通用域扩展名的所有域名的信息，例如 .com、.net 或 url 中最后一个点之后的任何内容。例如，.com <strong>TLD 域名服务器</strong>包含以“.com”结尾的每个网站的信息。如果用户正在搜索 google.com，则在收到来自<strong>根域名服务器</strong>的响应后，<strong>DNS解析器</strong>将向 .com <strong>TLD 域名服务器</strong>发送查询，后者将通过针对该域的<strong>权威性域名服务器</strong>进行响应。</p><p><strong>TLD 域名服务器</strong>的管理由 Internet 编号分配机构（IANA）加以处理，其为 ICANN 的一个分支机构。IANA 将 TLD 服务器分为两个主要组：</p><ul><li><strong>通用顶级域</strong>：这些是非特定国家&#x2F;地区的域，一些最知名的通用 TLD 包括 .com、.org、.net、.edu 和 .gov。</li><li><strong>国家&#x2F;地区代码顶级域</strong>：这些包括特定于某个国家&#x2F;地区或州的任何域。例如，uk、.us、.ru 和 .jp 等。</li></ul></li><li><p><strong>权威域名服务器</strong></p><p><strong>权威性域名服务器</strong>通常是解析器查找 IP 地址过程中的最后一步，如果<strong>权威域名服务器</strong>有权访问所请求的记录，它会将所请求主机名的 IP 地址返回给发出初始请求的 <strong>DNS解析器</strong>。</p></li></ul><h4 id="权威DNS服务器和递归DNS解析器有什么区别"><a href="#权威DNS服务器和递归DNS解析器有什么区别" class="headerlink" title="权威DNS服务器和递归DNS解析器有什么区别"></a>权威DNS服务器和递归DNS解析器有什么区别</h4><p>两种服务器都执行不同的角色并位于 DNS 查询管道内的不同位置</p><ul><li><p><strong>递归DNS解析器</strong><br><strong>DNS解析器</strong>是响应来自客户端的递归请求并花时间跟踪DNS 记录的计算机。它通过发出一系列请求来完成此操作，直到它到达所请求记录的<strong>权威 DNS 域名服务器</strong>（如果未找到记录，则超时或返回错误）。<strong>DNS 解析器</strong>并不总是需要发出多个请求来跟踪响应客户端所需的记录。<strong>缓存</strong>是一个数据持久性过程，它通过在 DNS 查找中更早地提供请求的资源记录来帮助缩短必要的请求。</p></li><li><p><strong>权威DNS服务器</strong><br><strong>权威 DNS 服务器</strong>是实际保存并负责 DNS 资源记录的服务器。这是位于 DNS 查找链底部的服务器，它将<strong>响应查询的资源记录</strong>，最终允许发出请求的 Web 浏览器到达访问网站或其他 Web 资源所需的 <strong>IP 地址</strong>。</p><p>在查询是针对<strong>子域</strong>的情况下，将在<strong>权威名称服务器</strong>之后的序列中添加一个额外的域名服务器，该域名服务器负责存储子域的CNAME 记录。</p></li></ul><h4 id="DNS查找的步骤"><a href="#DNS查找的步骤" class="headerlink" title="DNS查找的步骤"></a>DNS查找的步骤</h4><p>注意：DNS 查找信息通常会在查询计算机中<strong>本地缓存</strong>或在 <strong>DNS 基础结构中远程缓存</strong>。<strong>DNS 查找</strong>通常有 <strong>8</strong> 个步骤。<strong>有缓存 DNS 信息时，会跳过 DNS 查找过程中的步骤</strong>，从而使其更快。下面的示例概述了没有缓存时的所有 8 个步骤。</p><ol><li><p>用户在 Web 浏览器中键入“google.com”，查询进入 Internet 并由 <strong>DNS 递归解析器</strong>接收。</p></li><li><p>然后解析器查询 <strong>DNS 根名称服务器</strong> (.)。</p></li><li><p>然后，<strong>根服务器</strong>使用顶级域 <strong>(TLD) DNS 服务器</strong>（例如 .com 或 .net）的地址响应<strong>解析器</strong>，该服务器存储其域的信息。在搜索 google.com 时，我们的请求指向 .com TLD。</p></li><li><p>然后<strong>解析器</strong>向 .com <strong>TLD</strong> 发出请求。</p></li><li><p>然后，<strong>TLD 服务器</strong>使用域名称服务器 google.com 的 IP 地址进行响应。</p></li><li><p>最后，<strong>递归解析器</strong>向域的<strong>域名服务器</strong>发送查询。</p></li><li><p>然后 google.com 的 IP 地址从<strong>域名服务器</strong>返回到<strong>解析器</strong>。</p></li><li><p>然后 <strong>DNS 解析器</strong>使用最初请求的域的 IP 地址响应 Web 浏览器。</p></li><li><p>一旦 DNS 查找的 8 个步骤返回了 google.com 的 IP 地址，浏览器就能够发出对网页的请求（查询结束）。</p></li><li><p>浏览器向 IP 地址发出<a href="https://www.cloudflare.com/learning/ddos/glossary/hypertext-transfer-protocol-http/">HTTP</a>请求。</p></li><li><p>该 IP 上的服务器返回要在浏览器中呈现的网页。</p></li></ol><h3 id="什么是DNS解析器"><a href="#什么是DNS解析器" class="headerlink" title="什么是DNS解析器"></a>什么是DNS解析器</h3><p>DNS 解析器是 DNS 查找的第一站，它负责处理发出初始请求的客户端。解析器启动一系列查询，最终将 URL 转换为必要的 IP 地址。</p><p>注意：典型的未缓存 DNS 查找将涉及递归和迭代查询。</p><p>区分递归DNS查询和递归 DNS 解析器非常重要。查询是指向需要解析查询的 DNS 解析器发出的请求。DNS递归解析器是接受递归查询并通过发出必要请求来处理响应的计算机。</p><h3 id="DNS查询的类型有哪些"><a href="#DNS查询的类型有哪些" class="headerlink" title="DNS查询的类型有哪些"></a>DNS查询的类型有哪些</h3><p>在典型的 DNS 查找中，会发生三种类型的查询。通过使用这些查询的组合，DNS 解析的优化过程可以减少行进的距离。在理想情况下，缓存记录数据将可用，允许 DNS 域名服务器返回非递归查询。</p><h4 id="3种类型的DNS查询："><a href="#3种类型的DNS查询：" class="headerlink" title="3种类型的DNS查询："></a>3种类型的DNS查询：</h4><ol><li><strong>递归查询</strong>- 在递归查询中，DNS 客户端要求 DNS 服务器（通常是 DNS 递归解析器）以请求的资源记录或解析器找不到记录时的错误消息响应客户端。</li><li><strong>迭代查询</strong>- 在这种情况下，DNS 客户端将允许 DNS 服务器返回它可以返回的最佳答案。如果被查询的 DNS 服务器与查询名称<strong>不匹配</strong>，它将返回一个对域名称空间较低级别的<strong>权威 DNS 服务器</strong>的引用。然后，DNS 客户端将对引用地址进行查询。此过程将继续使用查询链中的其他 DNS 服务器，直到发生错误或超时。</li><li><strong>非递归查询</strong>- 这通常会在 DNS 解析器客户端向 DNS 服务器查询它有权访问的记录时发生，因为它对记录具有权威性，或者记录存在于其缓存中。通常，DNS 服务器会缓存 DNS 记录，以防止额外的带宽消耗和上游服务器的负载。</li></ol><h3 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h3><p>缓存的目的是将数据临时存储在一个位置，从而提高数据请求的性能和可靠性。DNS 缓存涉及将数据存储在<strong>更靠近请求客户端的位置</strong>，以便可以<strong>更早地解析 DNS 查询</strong>，并且可以<strong>避免 DNS 查找链下游的额外查询</strong>，从而<strong>缩短加载时间并减少带宽&#x2F;CPU 消耗</strong>。DNS 数据可以缓存在多个位置，每个位置都将存储 DNS 记录一段由生存时间 (TTL，是指数据包在被路由器丢弃之前被设置为存在于网络中的时间或“跳数”) 确定的时间。</p><ul><li><p><strong>浏览器DNS缓存</strong><br>现代 Web 浏览器默认设计为<strong>在一定时间内缓存 DNS 记录</strong>。目的很明显，<strong>DNS 缓存越靠近 Web 浏览器，必须采取的处理步骤就越少</strong>，以便检查缓存并向 IP 地址发出正确的请求。<strong>当请求 DNS 记录时，浏览器缓存是为请求的记录检查的第一个位置</strong>。</p></li><li><p><strong>操作系统（os）级别的DNS缓存</strong><br>操作系统级别的 DNS 解析器是 DNS 查询<strong>离开您的计算机之前的第二个也是最后一个本地站点</strong>。操作系统内部在处理此查询的进程通常称为<strong>“存根解析器”</strong>或 <strong>DNS 客户端</strong>。当存根解析器从应用程序收到请求时，它首先检查自己的缓存以查看是否有记录。如果没有，它会在本地网络外部向 Internet 服务提供商 (ISP) 内部的 DNS 递归解析器发送一个 DNS 查询（设置了递归标志）。</p><p>当 ISP 内部的递归解析器接收到 DNS 查询时，与之前的所有步骤一样，它还将检查请求的主机到 IP 地址的转换是否已存储在其本地持久层内。</p><p>递归解析器还具有其他功能，具体取决于其<strong>缓存中的记录类型</strong>：</p><ol><li>如果解析器没有<strong>A 记录</strong>，但有权威名称服务器的<strong>NS 记录</strong>，它将直接查询这些名称服务器，绕过 DNS 查询中的几个步骤。此快捷方式可防止从根和 .com 名称服务器（在我们搜索 google.com 中）进行查找，并有助于更快地解析 DNS 查询。</li><li>如果解析器没有 NS 记录，它将向 TLD 服务器（在我们的例子中为 .com）发送查询，跳过根服务器。</li><li>万一解析器没有指向 TLD 服务器的记录，它将查询根服务器。此事件通常在清除 DNS 缓存后发生。</li></ol></li></ul><h2 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP"></a>什么是HTTP</h2><p><strong>超文本传输协议</strong> (HTTP) 是万维网的基础，用于使用超文本链接加载网页。HTTP 是一种<strong>应用层</strong>协议，旨在在联网设备之间传输信息，并在网络协议栈的其他层之上运行。HTTP 上的典型流程涉及客户端机器向服务器发出请求，然后服务器发送响应消息。</p><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>HTTP 请求是互联网通信平台（如 Web 浏览器）请求加载网站所需信息的方式。</p><p>通过 Internet 发出的每个 HTTP 请求都带有一系列编码数据，这些数据携带不同类型的信息。一个典型的 HTTP 请求包含：</p><ol><li><strong>HTTP 版本类型</strong></li><li><strong>一个网址</strong></li><li><strong>HTTP 方法</strong></li><li><strong>HTTP 请求标头</strong></li><li><strong>可选的 HTTP 正文。</strong></li></ol><h4 id="什么是HTTP方法"><a href="#什么是HTTP方法" class="headerlink" title="什么是HTTP方法"></a>什么是HTTP方法</h4><p><strong>指示 HTTP 请求期望从查询的服务器获得的操作</strong>。例如，两种最常见的 HTTP 方法是“GET”和“POST”；<strong>“GET”请求期望返回信息</strong>（通常以网站的形式），而<strong>“POST”请求通常表明客户端正在向 Web 服务器提交信息</strong>（例如表单信息，例如提交的用户名和密码）。</p><h4 id="什么是HTTP请求标头"><a href="#什么是HTTP请求标头" class="headerlink" title="什么是HTTP请求标头"></a>什么是HTTP请求标头</h4><p>HTTP 标头包含<strong>存储在键值对中的文本信息</strong>，它们包含在每个 HTTP 请求（和响应）中。这些标头传达核心信息，例如<strong>客户端正在使用什么浏览器，正在请求什么数据</strong>。</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220401135618143-165295967956813.png" alt="image-20220401135618143" style="zoom: 33%;"><h4 id="HTTP请求正文中有什么"><a href="#HTTP请求正文中有什么" class="headerlink" title="HTTP请求正文中有什么"></a>HTTP请求正文中有什么</h4><p>请求的主体是包含请求正在传输的信息的“主体”的部分。<strong>HTTP 请求的正文包含提交给 Web 服务器的任何信息</strong>，例如用户名和密码，或输入到表单中的任何其他数据。</p><h3 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h3><p>HTTP 响应是 <strong>Web 客户端（通常是浏览器）从 Internet 服务器接收的响应 HTTP 请求的内容</strong>。这些响应根据 HTTP 请求中的要求传达有价值的信息。</p><p>典型的 HTTP 响应包含：</p><ol><li><strong>HTTP 状态码</strong></li><li><strong>HTTP 响应标头</strong></li><li><strong>可选的 HTTP 正文</strong></li></ol><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><ol><li><p>HTTP 状态代码是最常用于指示 HTTP 请求是否已成功完成的 3 位代码。状态码分为以下 5 个块：</p></li><li><ol><li><strong>1xx 信息</strong></li><li><strong>2xx 成功</strong></li><li><strong>3xx 重定向</strong></li><li><strong>4xx 客户端错误</strong></li><li><strong>5xx 服务器错误</strong></li></ol></li><li><ol><li><p>“xx”指的是 00 到 99 之间的不同数字。</p></li><li><p>以数字“2”开头的状态代码表示成功。例如，客户端请求网页后，最常见的响应状态码为“200 OK”，表示请求已正确完成。</p></li><li><p>如果响应以“4”或“5”开头，则表示出现错误，网页将不会显示。<strong>以“4”开头的状态代码表示客户端错误</strong>（在 URL 中打错字时遇到“404 NOT FOUND”状态代码是很常见的）。<strong>以“5”开头的状态码表示服务器端出现问题</strong>。状态代码也可以以“1”或“3”开头，分别表示信息响应和重定向。</p></li></ol></li></ol><h4 id="HTTP响应标头"><a href="#HTTP响应标头" class="headerlink" title="HTTP响应标头"></a>HTTP响应标头</h4><p>与HTTP 请求非常相似，HTTP 响应带有传达重要信息的标头，例如在响应正文中发送的数据的语言和格式。</p><img src="/2022/03/27/%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AE%B0/image-20220401204539200-165295967956814.png" alt="image-20220401204539200" style="zoom:50%;"><h4 id="HTTP响应文正内容"><a href="#HTTP响应文正内容" class="headerlink" title="HTTP响应文正内容"></a>HTTP响应文正内容</h4><p>对“GET”请求的成功 HTTP 响应通常具有包含<strong>请求信息的正文</strong>。在大多数 Web 请求中，这是 Web 浏览器将其转换为网页的 HTML 数据。</p><h1 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h1><h2 id="互联网-1"><a href="#互联网-1" class="headerlink" title="互联网"></a>互联网</h2><h3 id="A记录"><a href="#A记录" class="headerlink" title="A记录"></a>A记录</h3><p>“A”代表“地址”，这是最基础的 DNS记录类型：它表示给定域的 IP 地址。比如，拉取 cloudflare.com 的 DNS 记录，A 记录当前返回的 IP 地址为：104.17.210.9。</p><p>A 记录只保存 IPv4 地址。如果一个网站拥有 IPv6 地址，它将改用“AAAA”记录。</p><h3 id="DNS-NS记录"><a href="#DNS-NS记录" class="headerlink" title="DNS NS记录"></a>DNS NS记录</h3><p>NS 代表“域名服务器”，域名服务器记录指示哪个 DNS 服务器对该域具有权威性（即，哪个服务器包含实际 DNS 记录）。基本上，NS 记录告诉互联网可从哪里找到域的 IP 地址。一个域通常会有多个 NS 记录，这些记录可指示该域的主要和辅助域名服务器。倘若没有正确配置的 NS 记录，用户将无法加载网站或应用程序。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySql笔记</title>
    <link href="/2022/03/16/MySql%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/16/MySql%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="启动MySQL："><a href="#启动MySQL：" class="headerlink" title="启动MySQL："></a>启动MySQL：</h4><p> mysql -u(用户名) -p(明文密码)    （-p后可以不写密码直接回车就可以输入不是明文的密码）</p><h2 id="数据库操作："><a href="#数据库操作：" class="headerlink" title="数据库操作："></a>数据库操作：</h2><ul><li><p>查看所有数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs mysql">show databases;<br></code></pre></td></tr></table></figure></li><li><p>查看当前使用的数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select database();<br></code></pre></td></tr></table></figure></li><li><p>创建数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create databases 数据库名 charset-utf8;<br></code></pre></td></tr></table></figure></li><li><p>删除数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop database 数据库名;<br></code></pre></td></tr></table></figure></li><li><p>使用数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use database 数据库名;<br></code></pre></td></tr></table></figure></li><li><p>查看数据库中所有表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show tables;<br></code></pre></td></tr></table></figure></li></ul><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><ul><li><p>查看表结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">desc 表名;<br></code></pre></td></tr></table></figure></li><li><p>创建表结构的语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名(字段名 数据类型 可选的约束条件);<br>例：<br>create table TableName(id int unsigned auto_increment primary key not null,name varchar(10));<br></code></pre></td></tr></table></figure><p>创建了两个列，分别是int类型 id，字符串类型name</p><ul><li>int类型 id</li><li>unsigned 为“无符号”的意思。unsigned即为非负数，用此类型可以增加数据长度。</li><li>auto_increment 自增长</li><li>primary key 主键</li><li>not null 非空</li></ul></li><li><p>修改表–添加字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table 表名 add 列名 类型;<br>例：<br>alter table TableName add NowTime datetime;<br></code></pre></td></tr></table></figure></li><li><p>修改表–修改字段–不重命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table 表名 modify 列名 类型及约束;<br>例：<br>alter table TableName modify date nout noll;<br></code></pre></td></tr></table></figure></li><li><p>删除表–删除字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table 表名 drop 列名;<br>例：<br>alter table TableName drop NowTime;<br></code></pre></td></tr></table></figure></li><li><p>删除表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop table 表名;<br>例：<br>drop table TableName;<br></code></pre></td></tr></table></figure></li><li><p>查看表的创建语句–详细过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show create table 表名;<br>例：<br>show create table TableName;<br></code></pre></td></tr></table></figure></li></ul><h2 id="查询基本使用"><a href="#查询基本使用" class="headerlink" title="查询基本使用"></a>查询基本使用</h2><ul><li><p>查询所有列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from 表名;<br>例:<br>select * from TableName;<br></code></pre></td></tr></table></figure></li><li><p>查询指定列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列1，列2， ...from 表名;<br>例：<br>select id, name from TableName;<br></code></pre></td></tr></table></figure></li></ul><h2 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h2><p>说明：主键列是自动增长，但是在全列插入时需要占位，通常使用空值(0或者null);字段默认 值default 来占位，插入成功后以实际数据为准  </p><ul><li><p><strong>全列插入</strong>：值的顺序与表结构字段的顺序完全一一对应，此时字段名列表不用填写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into 表名 values(...);<br>例：<br>insert into TableName values(0,&#x27;name&#x27;,&#x27;2022-3-16&#x27;);<br></code></pre></td></tr></table></figure></li><li><p><strong>部分列插入</strong>：值的顺序与给出的列顺序对应，此时需要根据实际的数据的特点填写对应字段列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into 表名 (列1, ...) values(值1, ...);<br>例：<br>insert into students(id,name,NowTime )values(1,&#x27;name2&#x27;,&#x27;2022-3-16&#x27;);<br></code></pre></td></tr></table></figure><p>上面的语句一次可以向表中插入一行数据，还可以一次性插入多行数据，这样可以减少与数据库的通信。</p></li><li><p><strong>全列多行插入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into 表名 values(...),(...)...;<br>例：<br>insert into TableName values(0, &#x27;result1&#x27;),(0, &#x27;result2&#x27;);<br></code></pre></td></tr></table></figure></li><li><p><strong>部分列多行插入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into 表名(列1,...) values(值1,...),(值1,...)...;<br>例：<br>insert into TableName(name) values(&#x27;result1&#x27;),(&#x27;result2&#x27;),(&#x27;result3&#x27;);<br></code></pre></td></tr></table></figure></li><li><p><strong>修改</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update 表名 set 列1=值1,列2=值2... where 条件;<br>例：<br>update TableName set name=&#x27;new name&#x27;,NowTime=&#x27;2022-3-17&#x27; where id=3;<br></code></pre></td></tr></table></figure><p>修改id等于3的name和NowTime值</p></li><li><p><strong>删除</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from 表名 where 条件;<br>例：<br>delete from TableName where id=5;<br></code></pre></td></tr></table></figure></li><li><p><strong>as关键字</strong>：</p><ul><li><p>使用as给字段起别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select id as 序号,name as 名字, NowTime as 当前时间 from TableName;<br></code></pre></td></tr></table></figure></li><li><p>可以通过as给表起别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select t.id,t.name,t.NowTime from TableName as t;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="条件语句查询"><a href="#条件语句查询" class="headerlink" title="条件语句查询"></a>条件语句查询</h2><ul><li>where 后面支持多种运算符，进行条件的处理  </li><li>比较运算符  </li><li>逻辑运算符  </li><li>模糊查询  </li><li>范围查询  </li><li>空判断</li></ul><h4 id="比较运算符："><a href="#比较运算符：" class="headerlink" title="比较运算符："></a>比较运算符：</h4><ul><li><p>等于：&#x3D; </p></li><li><p>大于：&gt;  </p></li><li><p>大于等于：&gt;&#x3D;  </p></li><li><p>小于：&lt;  </p></li><li><p>小于等于：&lt;  </p></li><li><p>不等于：!&#x3D;</p></li><li><p>或&lt;  </p></li><li><p>例1：查询编号大于3的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where id 3;<br></code></pre></td></tr></table></figure></li><li><p>例2：查询编号不大于4的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where id &lt; 4;<br></code></pre></td></tr></table></figure></li><li><p>例3：查询姓名不是“黄蓉”的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where name !=黄蓉&#x27;;<br></code></pre></td></tr></table></figure></li><li><p>例4：查询没被删除的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where is delete=0;<br></code></pre></td></tr></table></figure></li></ul><h4 id="逻辑运算符："><a href="#逻辑运算符：" class="headerlink" title="逻辑运算符："></a>逻辑运算符：</h4><ul><li><p>and</p></li><li><p>or</p></li><li><p>not</p></li><li><p>例5：查询编号大于3的女同学  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where id 3 and gender=0;<br></code></pre></td></tr></table></figure></li><li><p>例6：查询编号小于4或没被删除的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where id 4 or is delete=0; <br></code></pre></td></tr></table></figure></li></ul><h4 id="模糊查询："><a href="#模糊查询：" class="headerlink" title="模糊查询："></a>模糊查询：</h4><ul><li><p>like</p></li><li><p>%（表示任意多个任意字符）</p></li><li><p>_（表示一个任意字符）</p></li><li><p>例7：查询姓黄的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where name like &#x27;黄%&#x27;;<br></code></pre></td></tr></table></figure></li><li><p>例8：查询姓黄并且“名”是一个字的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where name like &#x27;黄_&#x27;;<br></code></pre></td></tr></table></figure></li><li><p>例9：查询姓黄或叫靖的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where name like &#x27;黄%&#x27; or name like &#x27;%靖&#x27;;<br></code></pre></td></tr></table></figure></li></ul><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>范围查询分为连续范围查询和非连续范围查询 ,in表示在一个非连续的范围内  </p><ul><li><p>例10：查询编号是1或3或8的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where id in(1,3,8);<br></code></pre></td></tr></table></figure><p>betweer ..ad.表示在一个连续的范围内  </p></li><li><p>例11：查询编号为3至8的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where id between 3 and 8;<br></code></pre></td></tr></table></figure></li><li><p>例12：查询编号是3至8的男生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where (id between 3 and 8) and gender=1;<br></code></pre></td></tr></table></figure></li></ul><h4 id="空判断"><a href="#空判断" class="headerlink" title="空判断"></a>空判断</h4><p>判断为空</p><ul><li><p>例13：查询没有填写身高的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where height is null;  <br></code></pre></td></tr></table></figure><p>注意：1.null与是不同的2.is null   </p><p>判非空is not null</p></li><li><p>例14：查询填写了身高的学生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where height is not null;  <br></code></pre></td></tr></table></figure></li><li><p>例15：查询填写了身高的男生  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where height is not null and gender=1<br></code></pre></td></tr></table></figure></li><li><p>优先级：</p><p>优先级由高到低的顺序为：小括号，not，比较运算符，逻辑运算符and比or先运算，如果同时出现并希望先运算or，需要结合()使用</p></li></ul><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul><li><p>排序查询语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...];<br></code></pre></td></tr></table></figure></li><li><p>语法说明：</p><p>将行数据按照列1进行排序，如果某些行列1的值相同时，则按照列2排序，以此类推  </p><p>asc从小到大排列，即升序  </p><p>desc从大到小排序，即降序  </p><p>默认按照列值从小到大排列（即asc关键字）</p></li><li><p>例1：查询未删除男生信息，按学号降序  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where gender= 1 and is delete= 0 order by id desc; <br></code></pre></td></tr></table></figure></li><li><p>例2：查询未删除学生信息，按名称升序  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where is delete= 0 order by name;<br></code></pre></td></tr></table></figure></li><li><p>例3：显示所有的学生信息，先按照年龄从大-&gt;小排序，当年龄相同时按照身高从高-&gt;矮排 序  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students order by age desc, height desc;<br></code></pre></td></tr></table></figure></li></ul><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from 表名 limit start=0,count;<br></code></pre></td></tr></table></figure><p>说明：</p><p>从start 开始，获取count 条数据  </p><p>start 默认值为0  </p><p>也就是当用户需要获取数据的前n条的时候可以直接写上 xxx limit n;</p><ul><li><p>例：查询前3行男生信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where gender=1 limit 0,3;<br></code></pre></td></tr></table></figure><p>已知：每页显示m条数据，当前显示第n页</p><p>求总页数：此段逻辑后面会在python项目中实现  </p><p>查询总条数p1  </p><p>使用p1除以m得到p2  </p><p>如果整除则p2为总数页  </p><p>如果不整除则p2+1为总页数  </p><p>获取第n页的数据的SQL语句求解思路  </p><p>第n页前有n-1页  </p><p>所在第n页前已经显示的数据的总量是(n-1)*m </p><p>*由于数据的下标从0开始所以第n页前所有的网页的下标是 0,1,…,(n-1)*m-1</p><p>所以第n页的数据起始下标是(n-1)*m</p><p>获取第n页数据的SQL语句</p><p>select * from students where is_delete&#x3D;0 limit (n-1)*m,m   </p><p>注意：在sql语句中limit 后不可以直接加公式</p></li></ul><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p>总数</p><p>count(*)表示计算总行数，括号中写星与列号，结果是相同的</p><ul><li><p>例1：查询学生总数  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select count(*) from students; <br></code></pre></td></tr></table></figure><p>最大值  </p><p>max(列)表示求此列的最大值  </p></li><li><p>例2：查询女生的编号最大值  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select max(id) from students where gender=2;  <br></code></pre></td></tr></table></figure><p>最小值  </p><p>min(列)表示求此列的最小值  </p></li><li><p>例3：查询未删除的学生最小编号  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select min( id) from students where is_delete=0;<br></code></pre></td></tr></table></figure><p>求和  </p><p>sum(列)表示求此列的和</p></li><li><p>例4：查询男生的总年龄  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select sum(age) from students where gender=1;<br></code></pre></td></tr></table></figure><p>平均年龄  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select sum(age)/count(*) from students where gender=1;<br></code></pre></td></tr></table></figure><p>平均值  </p><p>avg(列)表示求此列的平均值  </p></li><li><p>例5：查询未删除女生的编号平均值  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select avg(id) from students where is_delete= 0 and gender=2;<br></code></pre></td></tr></table></figure></li></ul><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>group by   </p><p>group by + group concat()  </p><p>group_concat(字段名)根据分组结果，使用group _concat()来放置每一个分组中某字段的集合  </p><p>group by +聚合函数  </p><p>通过group_concat 的启发，我们既然可以统计出每个分组的某字段的值的集合，那么我们 也可以通过集合函数来对这个值的集合做一些操作  </p><p>group by + having   </p><p>having 条件表达式：用来过滤分组结果  </p><p>having 作用和lwhere 类似，但having只能用于group by 而where,是用来过滤表数据 </p><p>group by + with rollup   </p><p>with rollupl 的作用是：在最后新增一行，来记录当前表中该字段对应的操作结果，一般是汇总结果  </p><p>连接查询语法</p><p>对于外连接outer 关键字可以省略  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from 表1 inner或left或right join 表2 on 表1.列 运算符 表2.列;<br></code></pre></td></tr></table></figure><ul><li><p>例1：使用内连接查询班级表与学生表  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students inner join classes on students.cls_id = classes.id;<br></code></pre></td></tr></table></figure></li><li><p>例2：使用左连接查询班级表与学生表  </p><p>此处使用了as为表起别名，目的是编写简单  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students as s left join classes as c on s.cls_id = c.id;<br></code></pre></td></tr></table></figure></li><li><p>例3：使用右连接查询班级表与学生表  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students as s right join classes as c on s.cls_id c.id;<br></code></pre></td></tr></table></figure></li><li><p>例4：查询学生姓名及班级名称  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select s.name,c.name from students as s inner join classes as c on s.cls_id = c.id<br></code></pre></td></tr></table></figure></li></ul><p>子查询：</p><p>在一个select 语句中，嵌入了另外一个select 语句，那么被嵌入的select语句称之为子查询语句，外部那个select语句则称为主查询  </p><p>主查询和子查询的关系  </p><p>子查询是嵌入到主查询中  </p><p>子查询是辅助主查询的要么充当条件要么充当数据源  </p><p>子查询是可以独立存在的语句是一条完整的select 语句  </p><p>标量子查询  </p><p>查询班级学生平均年龄  </p><p>查询大于平均年龄的学生  </p><p>查询班级学生的平均身高  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where age &gt; (select avg(age) from students);<br></code></pre></td></tr></table></figure><p>列级子查询  </p><p>查询还有学生在班的所有班级名字</p><p>查询还有学生在班的所有班级名字  </p><p>找出学生表中所有的班级id </p><p>找出班级表中对应的名字  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select name from classes where id in (select cls_id from students);<br></code></pre></td></tr></table></figure><p>行级子查询  </p><p>需求：查找班级年龄最大身高最高的学生  </p><p>行元素：将多个字段合成一个行元素在行级子查询中会使用到行元素  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from students where (height,age) = (select max(height),max(age) from students);<br></code></pre></td></tr></table></figure><h4 id="UNION操作符"><a href="#UNION操作符" class="headerlink" title="UNION操作符"></a>UNION操作符</h4><p><strong>用于合并两个或多个 SELECT 语句的结果集。</strong></p><p>UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。</p><p>以下为不同的两个表中的country列</p><img src="/2022/03/16/MySql%E7%AC%94%E8%AE%B0/image-20220518182203683.png" alt="image-20220518182203683" style="zoom:67%;"><img src="/2022/03/16/MySql%E7%AC%94%E8%AE%B0/image-20220518182226084.png" alt="image-20220518182226084" style="zoom:67%;"><p>执行语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT country FROM Websites<br>UNION<br>SELECT country FROM apps<br>ORDER BY country;<br></code></pre></td></tr></table></figure><img src="/2022/03/16/MySql%E7%AC%94%E8%AE%B0/image-20220518182336814.png" alt="image-20220518182336814" style="zoom:67%;"><p>UNION指挥选取把不同的值，若想选取重复的值可使用UNION ALL</p><p>执行语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT country FROM Websites<br>UNION ALL<br>SELECT country FROM apps<br>ORDER BY country;<br></code></pre></td></tr></table></figure><img src="/2022/03/16/MySql%E7%AC%94%E8%AE%B0/image-20220518182531589.png" alt="image-20220518182531589" style="zoom:67%;"><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>用于限制查询结果返回的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from tablename limit i,nl<br></code></pre></td></tr></table></figure><ul><li>i：查询结果的索引值，即从0开始查找</li><li>n：查询结果返回的数量</li></ul><h4 id="information-schema-schemata"><a href="#information-schema-schemata" class="headerlink" title="information_schema.schemata"></a>information_schema.schemata</h4><p>获取所有数据库信息</p><img src="/2022/03/16/MySql%E7%AC%94%E8%AE%B0/image-20220519172542302.png" alt="image-20220519172542302" style="zoom:67%;"><h4 id="group-concat"><a href="#group-concat" class="headerlink" title="group_concat()"></a>group_concat()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select group_concat(column) from tablename;<br></code></pre></td></tr></table></figure><p>将相同字段在同一行显示</p><img src="/2022/03/16/MySql%E7%AC%94%E8%AE%B0/image-20220519173003658.png" alt="image-20220519173003658" style="zoom:67%;"><h4 id="select-查询某数据库表名"><a href="#select-查询某数据库表名" class="headerlink" title="select 查询某数据库表名"></a>select 查询某数据库表名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select table_name from information_schema.tables where table_schema=&#x27;test&#x27;;<br></code></pre></td></tr></table></figure><p>以上查询返回<strong>test数据库</strong>中的所有表</p><h4 id="select-查询表中的字段名"><a href="#select-查询表中的字段名" class="headerlink" title="select 查询表中的字段名"></a>select 查询表中的字段名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select column_name from information_schema.columns where table_name=&#x27;test&#x27;;<br></code></pre></td></tr></table></figure><p>以上返回<strong>test表</strong>中的所有字段名</p><h4 id="不使用use进入数据库，获取该数据库数据"><a href="#不使用use进入数据库，获取该数据库数据" class="headerlink" title="不使用use进入数据库，获取该数据库数据"></a>不使用use进入数据库，获取该数据库数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from database.table;<br></code></pre></td></tr></table></figure><p>database.table：数据库名.表名</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>有时候添加数据会显示语法错误，可能是因为添加的数据与其语法重名，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table gotodata add repeat varchar(100);//显示语法错误，因为repeat与语法重名<br>alter table gotodata add `repeat` varchar(100);//正确输入，使用反引号<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用hexo+Github搭建博客</title>
    <link href="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p><strong>环境需要</strong>：nodejs，git，hexo</p><p>下载安装nodejs，git</p><h2 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h2><ul><li><p>设置密钥</p><p>打开git bash</p></li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs jboss-cli">git config <span class="hljs-params">--global</span> user.name <span class="hljs-string">&quot;wuhahe&quot;</span><span class="hljs-comment"># 设置用户名</span><br>git config <span class="hljs-params">--global</span> user.email <span class="hljs-string">&quot;529516310@qq.com&quot;</span><span class="hljs-comment"># 设置用户名邮箱</span><br>git config <span class="hljs-params">--list</span><br></code></pre></td></tr></table></figure><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220303222320461.png" alt="image-20220303222320461" style="zoom: 50%;"><p>​        继续输入命令，修改邮箱</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;529516310@qq.com&quot;</span><br></code></pre></td></tr></table></figure><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220303222620044.png" alt="image-20220303222620044" style="zoom: 50%;"><p>​        进入.ssh文件夹，打开id_rsa.pub，全选复制密钥</p><ul><li><p>配置github</p><p>依次进入settings \ SSH and GPGkeys 点击New SSH key添加</p></li></ul><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220303223100169.png" alt="image-20220303223100169" style="zoom: 33%;"><p>​        设置完成！</p><h2 id="安装与使用hexo"><a href="#安装与使用hexo" class="headerlink" title="安装与使用hexo"></a><strong>安装与使用hexo</strong></h2><p><strong>下载安装hexo</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g hexo<br></code></pre></td></tr></table></figure><p>创建blog文件夹，用git打开hexo子文件夹，未来该文件夹用来存放代码。</p><ul><li><strong>初始化：</strong></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span><span class="hljs-meta"># j</span><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">hexo</span> g<span class="hljs-comment"># 生成静态文件</span><br>hexo s<span class="hljs-comment"># 启动本地服务</span><br></code></pre></td></tr></table></figure><p>​        接下来浏览器访问 <a href="http://localhost:4000，内容为hexo初始化自带的hello">http://localhost:4000，内容为hexo初始化自带的hello</a> world文章</p><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220303010919115.png" alt="image-20220303010919115" style="zoom: 25%;"><ul><li><p><strong>部署到GitHub</strong></p><p>修改目录下的 _config.yml中的deploy字段，添加仓库地址以及设置分支</p><p><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220303224123266.png" alt="image-20220303224123266"></p></li></ul><p>​        hexo提供了hexo-deployer-git插件，使用户能方便的部署到github仓库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> hexo-deployer-git<br></code></pre></td></tr></table></figure><p>​        至此执行命令 <code>hexo d</code> 即可部署到github仓库</p><h2 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h2><p>有许多用户开源的主题可以使用，这里使用了 hexo-theme-yun，主题文档：<a href="https://yun.yunyoujun.cn/guide/">https://yun.yunyoujun.cn/guide/</a></p><ul><li><p><strong>下载主题</strong></p><p>根据hexo文档提供的指令下载</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i hexo-theme-yun<br></code></pre></td></tr></table></figure></li><li><p><strong>修改 _config.yml</strong></p><p>找到theme字段，改为<code>theme: yun</code></p></li><li><p><strong>安装主题所需插件</strong></p><p>除了hexo自带的stylus，该主题还需要pug</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">npm install hexo-<span class="hljs-keyword">render</span>-pug hexo-<span class="hljs-keyword">renderer</span>-stylus<br></code></pre></td></tr></table></figure></li><li><p><strong>自定义主题配置</strong></p><p>根据主题文档，可以再目录下新建文件 _config.yun.yml，主题会自动载入该文件下的配置。</p><p>譬如修改头像，在 _config.yun.yml文件中添加：</p><p>在source下新建文件夹images</p><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220303230254080.png" alt="image-20220303230254080" style="zoom: 67%;"></li></ul><p>​        更多自定义配置参考主题文档</p><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><ul><li><p><strong>新建文章</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;文章名&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>修改 _config.yml文件</strong></p><p>找到 post_asset_folder字段，将false改为true。</p><p>修改后，每当我们新建一个文章，hexo就会自动生成一个主题同名文件夹，用来存放文章内的图片。</p><p>执行命令  :</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type"></span>&quot;<span class="hljs-keyword">new</span><span class="hljs-type"></span>博客<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>利用Typora撰写</strong></p><p>对以下选择进行勾选，这样我们复制图片在Typora时会自动在hexo生成的文件夹中保存。</p><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220303233844272.png" alt="image-20220303233844272" style="zoom: 50%;"></li><li><p><strong>设置分类，标签</strong></p><p>执行命令（设置分类）</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> categories<br></code></pre></td></tr></table></figure><p>该命令会在source文件夹下新建一个categories文件夹，打开其中的index.md文件，添加type行</p><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220324180520426.png" alt="image-20220324180520426" style="zoom:67%;"><p>这样就可以在文章中添加分类了，格式如下：</p><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220324180723367.png" alt="image-20220324180723367" style="zoom:67%;"><p>执行命令（设置标签）</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> tags<br></code></pre></td></tr></table></figure><p>步骤如上，在tags文件夹index.md文件添加type:  “tags”, 之后就能添加标签了</p><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220324181018213.png" alt="image-20220324181018213" style="zoom:67%;"></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p><strong>绑定域名</strong></p><p>需要先设定域名解析到GitHub仓库ip</p><p>在source文件夹下新建CNAME文件，内容为需要绑定的域名</p></li></ul><img src="/2022/03/03/%E5%88%A9%E7%94%A8hexo-Github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20220303234439102.png" alt="image-20220303234439102" style="zoom: 80%;"><p>​        部署完成后就可以通过访问hah3.com查看博客了</p><ul><li><p><strong>浏览器图片不显示</strong></p><p>图片地址重定向错误，安装插件解决，执行命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/CodeFalling/</span>hexo-asset-image --save<br></code></pre></td></tr></table></figure></li><li><p><strong>启动本地服务显示正常，部署到github后出现排版混乱</strong></p><p>需强制刷新浏览器缓存，shift+f5刷新，才能显示修改后的新界面</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
